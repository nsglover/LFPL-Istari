beginModule "Language";

openModule /List/;



(* TYPE *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    tp : type =
    | one : tp
    | diam : tp
    | plus : tp -> tp -> tp
    | tensor : tp -> tp -> tp
    | arrow : tp -> tp -> tp
    | dlist : tp -> tp
/;



(* CONTEXT *)

define /ctx/
/
  list tp
// 
  intersect (i : level) . U i
/;
unfold /ctx/.
typecheck.
qed();
reductions
/
  ctx --> list tp ;
  unfolding ctx
/;



(* CONTEXT SPLIT *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    split : ctx -> ctx -> ctx -> type =
    | all_right : forall (G : ctx) . split G nil G
    | left : forall (G G1 G2 : ctx) (A : tp) . split G G1 G2 -> split (A :: G) (A :: G1) G2
    | swap : forall (G G1 G2 : ctx) . split G G1 G2 -> split G G2 G1
/;
Database.setImplicits (parseConstant /all_right/) 1;
Database.setImplicits (parseConstant /left/) 4;
Database.setImplicits (parseConstant /swap/) 3;


define /all_left {G}/
/
  swap all_right
//
  forall (G : ctx) . split G G nil
/;
unfold /all_left/.
typecheck.
qed ();
reductions
/
  all_left G --> swap G nil G (all_right G) ;
  unfolding all_left
/;


define /right {G G1 G2 A} S/
/
  swap (left (swap S))
//
  forall (G G1 G2 : ctx) (A : tp) . split G G1 G2 -> split (A :: G) G1 (A :: G2)
/;
unfold /right/.
typecheck.
qed ();
reductions
/
  right G G1 G2 A S --> swap (A :: G) (A :: G2) G1 (left G G2 G1 A (swap G G1 G2 S)) ;
  unfolding right
/;



(* DEBRUIJN INDEX *)

typedef
/
  datatype
    intersect (i : level) . intermediate (A : tp) . U i
  of
    index : ctx -> type =
    | izero : forall (G : ctx) . index (A :: G)
    | isucc : forall (G : ctx) (B : tp) . index G -> index (B :: G)
/;
Database.setImplicits (parseConstant /izero/) 1;
Database.setImplicits (parseConstant /isucc/) 2;


define /index_absurd/
/
  fn _ . Miscellaneous.bogus
//
  intersect (A : tp) . index A nil -> void
/;
unfold /index_absurd/.
introOf /A x/.
reduce //.
destruct /x/ /{G h_cons | G B x h_cons}/ >> injection /h_cons/.
qed ();


define /index_case {A G} x case_izero case_isucc/
/
  index_iter Miscellaneous.bogus Miscellaneous.bogus
  (fn G . case_izero G) (fn G B x _ . case_isucc G B x) Miscellaneous.bogus x
//
  intersect (i : level) (P : ctx -> U i) .
  forall (A : tp) (G : ctx) . index A G -> 
  (forall (G : ctx) . P (A :: G)) -> (forall (G : ctx) (B : tp) . index A G -> P (B :: G)) ->
  P G
/;
unfold /index_case/.
introOf /i P A G x case_izero case_isucc/.
reduce //.
destruct /x/ /{G' h_cons | G' B' x h_cons}/ >> reduce // >> auto.
qed ();
reductions
/
    index_case _ _ (izero G) nilcase _ --> nilcase G ;
    index_case _ _ (isucc G B x) _ conscase --> conscase G B x ;
    unfolding index_case
/;



(* TERM *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    term : ctx -> tp -> type =
    | var :
        forall (G : ctx) (A : tp) .
        index A G ->
        term G A
    | triv :
        forall (G : ctx) .
        term G one
    | inj1 :
        forall (G : ctx) (A B : tp) .
        term G A ->
        term G (plus A B)
    | inj2 : 
        forall (G : ctx) (A B : tp) .
        term G B ->
        term G (plus A B)
    | match : 
        forall (G GAB GC : ctx) (A B C : tp) .
        split G GAB GC -> term GAB (plus A B) -> term (A :: GC) C -> term (B :: GC) C ->
        term G C
    | pair :
        forall (G GA GB : ctx) (A B : tp) .
        split G GA GB -> term GA A -> term GB B ->
        term G (tensor A B)
    | letp :
        forall (G GAB GC : ctx) (A B C : tp) .
        split G GAB GC -> term GAB (tensor A B) -> term (B :: A :: GC) C ->
        term G C
    | lam :
        forall (G : ctx) (A B : tp) .
        term (A :: G) B ->
        term G (arrow A B)
    | app :
        forall (G GAB GA : ctx) (A B : tp) .
        split G GAB GA -> term GAB (arrow A B) -> term GA A ->
        term G B
    | lfold :
        forall (G : ctx) (A : tp) .
        term G (plus one (tensor diam (tensor A (dlist A)))) ->
        term G (dlist A)
    | lrec :
        forall (G : ctx) (A B : tp) .
        term G (dlist A) -> term (plus one (tensor diam (tensor A B)) :: nil) B ->
        term G B
/;
Database.setImplicits (parseConstant /var/) 2;
Database.setImplicits (parseConstant /triv/) 1;
Database.setImplicits (parseConstant /inj1/) 3;
Database.setImplicits (parseConstant /inj2/) 3;
Database.setImplicits (parseConstant /match/) 6;
Database.setImplicits (parseConstant /pair/) 5;
Database.setImplicits (parseConstant /letp/) 6;
Database.setImplicits (parseConstant /lam/) 3;
Database.setImplicits (parseConstant /app/) 5;
Database.setImplicits (parseConstant /lfold/) 2;
Database.setImplicits (parseConstant /lrec/) 3;



endModule ();