beginModule "Language";

openModule /List/;



(* TYPE *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    tp : type =
    | one : tp
    | diam : tp
    | plus : tp -> tp -> tp
    | tensor : tp -> tp -> tp
    | arrow : tp -> tp -> tp
    | stack : tp -> tp
    | dlist : tp -> tp
/;



(* CONTEXT *)

define /ctx/
/
  list tp
// 
  intersect (i : level) . U i
/;
withTypecheck (unfold /ctx/). qed();
reductions
/
  ctx --> list tp ;
  unfolding ctx
/;



(* CONTEXT SPLIT *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    split : ctx -> ctx -> ctx -> type =
    | all_right : forall (G : ctx) . split G nil G
    | left : forall (G G1 G2 : ctx) (A : tp) . split G G1 G2 -> split (A :: G) (A :: G1) G2
    | swap : forall (G G1 G2 : ctx) . split G G1 G2 -> split G G2 G1
/;
Database.setImplicits (parseConstant /all_right/) 1;
Database.setImplicits (parseConstant /left/) 4;
Database.setImplicits (parseConstant /swap/) 3;


define /all_left {G}/
/
  swap all_right
//
  forall (G : ctx) . split G G nil
/;
withTypecheck (unfold /all_left/). qed ();
reductions
/
  all_left G --> swap G nil G (all_right G) ;
  unfolding all_left
/;


define /right {G G1 G2 A} S/
/
  swap (left (swap S))
//
  forall (G G1 G2 : ctx) (A : tp) . split G G1 G2 -> split (A :: G) G1 (A :: G2)
/;
withTypecheck (unfold /right/). qed ();
reductions
/
  right G G1 G2 A S --> swap (A :: G) (A :: G2) G1 (left G G2 G1 A (swap G G1 G2 S)) ;
  unfolding right
/;



(* TERM *)

typedef
/
  datatype
    U 0
  of
    term : ctx -> tp -> type =
    | drop :
        forall (G : ctx) (A B : tp) .
        term G B ->
        term (A :: G) B
    | var :
        forall (G : ctx) (A : tp) .
        term (A :: G) A
    | triv :
        forall (G : ctx) .
        term G one
    | inj1 :
        forall (G : ctx) (A B : tp) .
        term G A ->
        term G (plus A B)
    | inj2 : 
        forall (G : ctx) (A B : tp) .
        term G B ->
        term G (plus A B)
    | match : 
        forall (G GAB GC : ctx) (A B C : tp) .
        split G GAB GC -> term GAB (plus A B) -> term (A :: GC) C -> term (B :: GC) C ->
        term G C
    | pair :
        forall (G GA GB : ctx) (A B : tp) .
        split G GA GB -> term GA A -> term GB B ->
        term G (tensor A B)
    | letp :
        forall (G GAB GC : ctx) (A B C : tp) .
        split G GAB GC -> term GAB (tensor A B) -> term (A :: B :: GC) C ->
        term G C
    | lam :
        forall (G : ctx) (A B : tp) .
        term (A :: G) B ->
        term G (arrow A B)
    | app :
        forall (G GAB GA : ctx) (A B : tp) .
        split G GAB GA -> term GAB (arrow A B) -> term GA A ->
        term G B
    | sfold :
        forall (G : ctx) (A : tp) .
        term G (plus one (tensor A (stack A))) ->
        term G (stack A)
    | sunfold :
        forall (G : ctx) (A : tp) .
        term G (stack A) ->
        term G (plus one (tensor A (stack A)))
    | lfold :
        forall (G : ctx) (A : tp) .
        term G (plus one (tensor diam (tensor A (dlist A)))) ->
        term G (dlist A)
    | lrec :
        forall (G : ctx) (A B : tp) .
        term G (dlist A) -> term (plus one (tensor diam (tensor A B)) :: nil) B ->
        term G B
/;
Database.setImplicits (parseConstant /drop/) 3;
Database.setImplicits (parseConstant /var/) 2;
Database.setImplicits (parseConstant /triv/) 1;
Database.setImplicits (parseConstant /inj1/) 3;
Database.setImplicits (parseConstant /inj2/) 3;
Database.setImplicits (parseConstant /match/) 6;
Database.setImplicits (parseConstant /pair/) 5;
Database.setImplicits (parseConstant /letp/) 6;
Database.setImplicits (parseConstant /lam/) 3;
Database.setImplicits (parseConstant /app/) 5;
Database.setImplicits (parseConstant /sfold/) 2;
Database.setImplicits (parseConstant /sunfold/) 2;
Database.setImplicits (parseConstant /lfold/) 2;
Database.setImplicits (parseConstant /lrec/) 3;




endModule ();