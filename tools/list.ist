openModule /List/;

File.import "../core/core-load.iml";
File.import "../util/util-load.iml";

beginModule "ListTools";



(* LIST NIL AND CONS *)

define /lnil {G A}/
/
  lfold (inj1 triv)
//
  forall (G : ctx) (A : tp) . term G (dlist A)
/;
withTypecheck (unfold /lnil/). qed ();
reductions
/
  term_sem _ _ (lnil _ _) _ --> nil ;
  unfolding lnil
/;


define /lcons {G Gd Ght Gh Gt A} T Tht Md Mh Mt/
/
  lfold (inj2 (pair T Md (pair Tht Mh Mt)))
//
  forall (G Gd Ght Gh Gt : ctx) (A : tp) . split G Gd Ght -> split Ght Gh Gt ->
  term Gd diam -> term Gh A -> term Gt (dlist A) -> term G (dlist A)
/;
withTypecheck (unfold /lcons/). qed ();
reductions
/
  term_sem _ _ (lcons G Gd Ght Gh Gt A T Tht Md Mh Mt) S --> 
    let (_, Sht) = s_split tp_sem G Gd Ght T S in
    let (Sh, St) = s_split tp_sem Ght Gh Gt Tht Sht in
    term_sem Gh A Mh Sh :: term_sem Gt (dlist A) Mt St ;
  unfolding lcons Tuple.letpair
/;



(* STACK NIL AND CONS *)

define /snil {G A}/
/
  sfold (inj1 triv)
//
  forall (G : ctx) (A : tp) . term G (dstack A)
/;
withTypecheck (unfold /snil/). qed ();
reductions
/
  term_sem _ _ (snil _ _) _ --> nil ;
  unfolding snil
/;


define /scons {G Gh Gt A} T Mh Mt/
/
  sfold (inj2 (pair T Mh Mt))
//
  forall (G Gh Gt : ctx) (A : tp) . split G Gh Gt -> term Gh A -> term Gt (dstack A) -> term G (dstack A)
/;
withTypecheck (unfold /scons/). qed ();
reductions
/
  term_sem _ _ (scons G Gh Gt A T Mh Mt) S --> 
    let (Sh, St) = s_split tp_sem G Gh Gt T S in
    term_sem Gh A Mh Sh :: term_sem Gt (dstack A) Mt St ;
  unfolding scons Tuple.letpair
/;



(* LIST FOLDR AND FOLDL *)

define /lrec_foldr {G GA GB A B} T M N1 N2/
/
  app T
  (
    lrec M
    (
      match all_left var
      (
        drop (lam var)
      )
      (
        letp all_left var
        (
          letp (right all_left) var
          (
            lam
            (
              app (right (left (right all_left))) (lam N2) (app (right all_left) var var)
            )
          )
        )
      )
    )
  )
  N1
//
  forall (G GA GB : ctx) (A B : tp) .
  split G GA GB -> term GA (dlist A) -> term GB B -> term (B :: A :: diam :: nil) B ->
  term G B
/;
withTypecheck (unfold /lrec_foldr/). qed ();

lemma "lrec_foldr_correctness"
/
  forall (G GA GB : ctx) (A B : tp) (T : split G GA GB) (S : subst tp_sem G) .
  forall (M : term GA (dlist A)) (N1 : term GB B) (N2 : term (B :: A :: diam :: nil) B) .
  term_sem (lrec_foldr T M N1 N2) S =
  (
    foldr (term_sem N1 (s_split T S #2))
    (fn va acc . term_sem N2 (s_cons acc (s_cons va (s_cons () s_nil))))
    (term_sem M (s_split T S #1))
  ) : tp_sem B
/;
inference.
intro /G GA GB A B T S M N1 N2/.
unfold /lrec_foldr/.
reduce //.
unfold /Tuple.letpair/.
generalize /term_sem M (s_split T S #1)/ /_/ /v/.
induction /v/ >>> [reflexivity, idtac].
intro /v vs ih/.
rewrite /-> ih/.
reflexivity.
qed ();


define /lrec_foldl {G GA GB A B} T M N1 N2/
/
  app T
  (
    lrec M
    (
      match all_left var
      (
        drop (lam var)
      )
      (
        letp all_left var
        (
          letp (right all_left) var
          (
            lam
            (
              app (right (right (left all_right))) var N2
            )
          )
        )
      )
    )
  )
  N1
//
  forall (G GA GB : ctx) (A B : tp) .
  split G GA GB -> term GA (dlist A) -> term GB B -> term (B :: A :: diam :: nil) B ->
  term G B
/;
withTypecheck (unfold /lrec_foldl/). qed ();

lemma "lrec_foldl_correctness"
/
  forall (G GA GB : ctx) (A B : tp) (T : split G GA GB) (S : subst tp_sem G) .
  forall (M : term GA (dlist A)) (N1 : term GB B) (N2 : term (B :: A :: diam :: nil) B) .
  term_sem (lrec_foldl T M N1 N2) S =
  (
    foldl (term_sem N1 (s_split T S #2)) 
    (fn va acc . term_sem N2 (s_cons acc (s_cons va (s_cons () s_nil))))
    (term_sem M (s_split T S #1))
  ) : tp_sem B
/;
inference.
intro /G GA GB A B T S M N1 N2/.
unfold /lrec_foldl/.
reduce //.
unfold /Tuple.letpair/.
generalize /term_sem M (s_split T S #1)/ /_/ /v/.
generalize /term_sem N1/ /_/ /f/.
revert /f/.
induction /v/ >>> [intros >>+ reflexivity, idtac].
intro /v vs ih f/.
exact /ih (fn SN . term_sem N2 (s_cons (f SN) (s_cons v (s_cons () s_nil))))/.
qed ();



(* APPEND *)

define /lappend A/
/
  lam
  (
    lrec_foldr all_left var (lam var)
    (lam (lcons (right (right (right all_left))) (right (right all_left)) var var (app (right all_left) var var)))
  )
//
  forall (A : tp) . term nil (arrow (dlist A) (arrow (dlist A) (dlist A)))
/;
withTypecheck (unfold /lappend/). qed ();


lemma "lappend_correctness"
/
  forall (A : tp) (l1 l2 : list (tp_sem A)) .
  (`term_sem _ (arrow (dlist A) (arrow _ _)) (lappend A) s_nil) l1 l2 = append l1 l2 : list (tp_sem A)
/;
intro /A l1 l2/ >> inference >> unfold /lappend/ >> reduce //.
rewrite /-> lrec_foldr_correctness _# 10/ >> reduce //.
induction /l1/ >> auto.
qed ();



(* LIST CASE ANALYSIS *)

define /lunfold {G A} M/
/
  lrec M 
  (
    match all_left var (inj1 triv)
    (
      letp all_left var
      (
        letp (right all_left) var
        (
          inj2
          (
            pair (right (right all_left)) var
            (
              pair (left all_right) var (lfold var)
            )
          )
        )
      )
    )
  )
//
  forall (G : ctx) (A : tp) .
  term G (dlist A) -> term G (plus one (tensor diam (tensor A (dlist A))))
/;
withTypecheck (unfold /lunfold/). qed ();

lemma "lunfold_correctness"
/
  forall (G : ctx) (A : tp) (M : term G (dlist A)) (S : subst tp_sem G) . 
  term_sem (lunfold M) S = 
  (
    case term_sem M S : list of
    | nil . inl ()
    | cons v vs . inr ((), v, vs)
  ) : (unit % (unit & tp_sem A & list (tp_sem A)))
/;
inference.
intro /G A M S/.
unfold /lunfold/ >> reduce // >> unfold /Tuple.letpair/.
generalize /term_sem M S/ /_/ /v/ >> clear /M/.
induction /v/ >>> [reflexivity, idtac].
{
  intro /v vs ih/.
  repeatn 3 compat.
  rewrite /-> ih/.
  destruct /vs/ /| v' vs'/ >> reduce // >> reflexivity.
}
qed ();


define /lmatch {G GM GN A B} T M N1 N2/
/
  match T (lunfold M) (drop N1)
  (
    letp (left all_right) var
    (
      letp (right (left all_right)) var N2
    )
  )
//
  forall (G GM GN : ctx) (A B : tp) .
  split G GM GN -> term GM (dlist A) -> term GN B -> term (A :: dlist A :: diam :: GN) B ->
  term G B
/;
withTypecheck (unfold /lmatch/). qed ();

lemma "match_correctness"
/
  forall (G GM GN : ctx) (A B : tp) (T : split G GM GN) (S : subst tp_sem G) .
  forall (M : term GM (dlist A)) (N1 : term GN B) (N2 : term (A :: dlist A :: diam :: GN) B) . 
  term_sem (lmatch T M N1 N2) S = 
  (
    let (SM, SN) = s_split T S in
    (
      case term_sem M SM : list of
      | nil . term_sem N1 SN
      | cons v vs . term_sem N2 (s_cons v (s_cons vs (s_cons () SN)))
    )
  ) : tp_sem B
/;
inference.
intro /G GM GN A B T S M N1 N2/.
unfold /lmatch/.
reduce //.
repeatn 4 (unfold /Tuple.letpair/).
remember /term_sem (lunfold M) (s_split T S #1)/ /_/ /unfold_v/ /h_unfold_v/.
rewrite /-> lunfold_correctness _# 4 in h_unfold_v/.
revert /h_unfold_v/.
generalize /term_sem M (s_split T S #1)/ /_/ /v/.
intro /h_unfold_v/.
destruct /v/ /| v vs/ >> subst /unfold_v/ >> auto.
qed ();



(* LIST-STACK CONVERSION *)

define /list_to_stack A/
/
  lam
  (
    lrec_foldr all_left var
    (pair all_right snil lnil)
    (
      letp (left all_right) var
      (
        pair (left (right (left all_right)))
        (scons (right all_left) var var)
        (lcons (right all_left) all_right var triv var)
      )
    )
  )
//
  forall (A : tp) . term nil (arrow (dlist A) (tensor (dstack A) (dlist one)))
/;
withTypecheck (unfold /list_to_stack/). qed ();


lemma "list_to_stack_correctness"
/
  forall (A : tp) (l : list (tp_sem A)) .
  let (l', m) = `term_sem _ (arrow (dlist A) (tensor (dstack A) (dlist one))) (list_to_stack A) s_nil l in
  (l' = l : list (tp_sem A)) & (length m = length l : nat)
/;
intro /A l/ >> unfold /list_to_stack/ >> induction /l/ >>> [rewrite /-> lrec_foldr_correctness/ >> auto, idtac].
intro /x l/ >> repeatn 2 (rewrite /-> lrec_foldr_correctness/) >> reduce //.
repeatn 8 (unfold /Tuple.letpair/) >> intro /ih/ >> split >>> [compat >> exact /ih #1/, idtac].
reduce // >> compat >> exact /ih #2/.
qed ();



(* LIST SUSPENSION *)

define /susp A/
/
  lam
  (
    lrec var
    (
      match all_left var
      (
        drop (pair all_right (lam lnil) lnil)
      )
      (
        letp all_left var
        (
          letp (right all_left) var
          (
            letp (right (left (all_right))) var
            (
              pair (left (right (left (all_right))))
              (
                lam 
                (
                  lmatch (left all_right) var lnil
                  (
                    drop
                    (
                      lcons (right (left all_right)) (right (right all_left)) var var
                      (
                        app (right all_left) var var
                      )
                    )
                  )
                )
              )
              (
                lcons (right all_left) all_right var triv var
              )
            )
          )
        )
      )
    )
  )
//
  forall (A : tp) . term nil (arrow (dlist A) (tensor (arrow (dlist one) (dlist A)) (dlist one)))
/;
withTypecheck (unfold /susp/). qed ();


lemma "susp_correct"
/
  forall (A : tp) (l : tp_sem (dlist A)) . 
  let susp_tp = (arrow (dlist A) (tensor (arrow (dlist one) (dlist A)) (dlist one))) in
  let (f, m) = (`term_sem nil susp_tp (susp A) (`s_nil tp_sem)) l in 
  length m = length l : nat & f m = l : list (tp_sem A)
/;
intro /A l/.
unfold /susp/.
reduceHard //.
induction /l/ >>> [split >> auto, idtac].
{
  intro /v vs/.
  repeat (unfold /lmatch/) >> repeat (unfold /lunfold/).
  repeat (unfold /Tuple.letpair/) >> reduceHard //.
  intro /ih/.
  destruct /ih/ /ih_len ih_eval/.
  split >>> [compat >> exact /ih_len/, idtac] >> clear /ih_len/.
  reduce //.
  compat.
  rewrite /<- ih_eval at 2/ >> clear /ih_eval v/.
  compat.
  repeat (unfold /Tuple.letpair/).
  reduce //.
  induction /vs/ >>> [reflexivity, idtac].
  intro /v vs ih/.
  reduce //.
  compat.
  exact /ih/.
}
qed ();



endModule ();