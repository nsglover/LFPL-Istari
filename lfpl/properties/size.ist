openModule /Nat/;
openModule /List/;

File.import "../core/load.iml";

beginModule "Size";



(* SIZE PREDICATE *)

defineInd //
/
  size_pred : forall (A : tp) . tp_sem A -> exists (P : U 0) . P -> nat of
  | one . fn _ . (unit , (fn _ . 0))
  | diam . fn _ . (unit , (fn _ . 1))
  | plus A B . fn v . 
    case v of
    | inl va . size_pred A va
    | inr vb . size_pred B vb
  | tensor A B . fn v .
    (
      size_pred A (v #1) #1 & size_pred B (v #2) #1,
      (fn p . size_pred A (v #1) #2 (p #1) + size_pred B (v #2) #2 (p #2))
    )
  | arrow A B . fn v .
    (
      (
        exists (v_pres : forall (va : tp_sem A) . size_pred A va #1 -> size_pred B (v va) #1) (n : nat).
        forall (va : tp_sem A) (va_has_size : size_pred A va #1) .
        (size_pred B (v va) #2) (v_pres va va_has_size) <= n + (size_pred A va #2) va_has_size
      ),
      (fn p . p #2 #1)
    )
  | dlist A . fn v .
  (
    Forall (fn va . size_pred A va #1) v,
    (
      fn p . 
      (
        fnind forall_fn : Forall [(tp_sem A) (fn va . size_pred A va #1)] _ -> nat of
        | Forall_nil . 0
        | Forall_cons va _ va_has_size tail_has_size . 
          succ ((size_pred A va #2) va_has_size) + forall_fn tail_has_size
      ) v p
    )
  )
//
  forall (A : tp) . tp_sem A -> exists (P : U 0) . P -> nat
/;


define /has_size {A} v/
/
  size_pred A v #1
//
  forall (A : tp) . tp_sem A -> U 0
/;
withTypecheck (unfold /has_size/). qed ();
reductions
/
  has_size (one) _ --> unit ;
  has_size (diam) _ --> unit ;
  has_size (plus A B) (inl v) --> has_size A v ;
  has_size (plus A B) (inr v) --> has_size B v ;
  has_size (tensor A B) v --> has_size A (v #1) & has_size B (v #2) ;
  has_size (dlist A) v --> Forall (tp_sem A) (has_size A) v ;
  unfolding has_size
/;


define /size {A v} v_has_size/
/
  size_pred A v #2 v_has_size
//
  forall (A : tp) (v : tp_sem A) . has_size v -> nat
/;
withTypecheck (unfold /has_size, size/). qed ();
reductions
/
  size (one) _ _ --> 0 ;
  size (diam) _ _ --> 1 ;
  size (plus A B) (inl v) v_has_size --> size A v v_has_size ;
  size (plus A B) (inr v) v_has_size --> size B v v_has_size ;
  size (tensor A B) v v_has_size --> size A (v #1) (v_has_size #1) + size B (v #2) (v_has_size #2) ;
  size (arrow _ _) _ v_has_size --> v_has_size #2 #1 ;
  has_size (arrow A B) v -->
    exists (v_pres : forall (va : tp_sem A) . has_size A va -> has_size B (v va)) (n : nat).
    forall (va : tp_sem A) (va_has_size : has_size A va) .
    size B (v va) (v_pres va va_has_size) <= n + size A va va_has_size ;
  size (dlist A) _ (Forall_nil _ _) --> 0 ;
  size (dlist A) _ (Forall_cons _ _ v vs v_has_size vs_has_size) -->
    succ (size A v v_has_size) + size (dlist A) vs vs_has_size ;
  unfolding has_size size
/;



(* SUBSTITUTION SIZE LEMMAS *)

define /sized_val A/
/
  exists (v : tp_sem A) . has_size v
//
  intersect (i : level) . tp -> U i
/;
withTypecheck (unfold /sized_val/). qed ();
setOpacity /sized_val/ Constant.SOFT;


define /s_size {G} S/
/
  s_fold S (fn _ v_sized r . size (v_sized #2) + r) 0
//
  forall (G : ctx) . subst sized_val G -> nat
/;
withTypecheck (unfold /s_size/). qed ();
reductions
/
  s_size _ (s_nil _) --> 0 ;
  s_size _ (s_cons _ A G v S) --> size A (v #1) (v #2) + s_size G S ;
  s_size _ (Forall_nil _ _) --> 0 ;
  s_size _ (Forall_cons _ _ A G v S) --> size A (v #1) (v #2) + s_size G S ;
  unfolding size s_size
/;


lemma "s_split_size"
/
  forall (G G1 G2 : ctx) (T : split G G1 G2) (S : subst sized_val G) .
  let (S1, S2) = s_split T S in
  s_size S = s_size S1 + s_size S2 : nat
/;
repeat (unfold /s_size/).
intro /G G1 G2 T/.
induction /T/ >> attempt (intro /G S/ >> reduce // >> reflexivity).
{
  intro /G G1 G2 A T ih S/.
  destruct /S/ /{h_nil | A' G' v_sized S h_cons}/ >> attempt (injection /h_nil/).
  injection /h_cons/ >> reintro /h_A h_G/ >> clear /h_cons/.
  repeat (unfold /Tuple.letpair/). 
  reduce //.
  transitivity /_/.
  1:{
    symmetry.
    apply /plus_assoc/ >> auto.
  }
  apply /plus_compat/ >> auto.
  unfold /Tuple.letpair in ih/.
  exact /ih S/ >> auto.
}
{
  intro /G G1 G2 T ih S/.
  repeat (unfold /Tuple.letpair/).
  unfold /Tuple.letpair in ih/.
  transitivity /_/.
  1:{
    apply /plus_commute/.
  }
  exact /ih S/.
}
qed ();


define /s_to_vals {G} S/
/
  s_map S (fn _ v_sized . v_sized #1)
//
  forall (G : ctx) . subst sized_val G -> subst tp_sem G
/;
withTypecheck (unfold /s_to_vals/). qed ();
reductions
/
  s_to_vals _ (s_cons _ A G v S) --> s_cons tp_sem A G (v #1) (s_to_vals G S) ;
  s_to_vals _ (s_nil _ ) --> s_nil tp_sem ;
  unfolding s_to_vals
/;


lemma "s_split_to_vals"
/
  forall (G G1 G2 : ctx) (T : split G G1 G2) (S : subst sized_val G) . 
  let (S1, S2) = s_split T S in
  let (S1v, S2v) = s_split T (s_to_vals S) in
  (s_to_vals S1 = S1v : subst tp_sem G1) & (s_to_vals S2 = S2v : subst tp_sem G2)
/;
intro /G G1 G2 T/.
repeat (unfold /s_to_vals/).
induction /T/.
{
  intro /G S/.
  auto.
}
{
  intro /G G1 G2 A T ih S/.
  destruct /S/ /{h_nil | A' G' v_sized S h_cons}/ >> attempt (injection /h_nil/).
  injection /h_cons/ >> reintro /h_A h_G/ >> clear /h_cons/.
  repeat (unfold /Tuple.letpair/). 
  repeatn 2 (unfold /Tuple.letpair in ih/).
  reduce // >> split >> reduce //.
  {
    compat.
    exact /ih S #1/ >> auto.
  }
  exact /ih S #2/ >> auto.
}
{
  intro /G G1 G2 T ih S/.
  repeat (unfold /Tuple.letpair/).
  repeatn 2 (unfold /Tuple.letpair in ih/).
  exact /(ih S #2, ih S #1)/.
}
qed ();



(* SIZE TOTALITY AND BOUNDEDNESS THEOREM *)

lemma "size_total_and_bounded"
/
  forall (G : ctx) (A : tp) (M : term G A) .
  forall (S : subst sized_val G) .
  exists (M_has_size : has_size (term_sem M (s_to_vals S))) .
  size M_has_size <= s_size S
/;
intro /G A M/.
induction /M/.
(* drop *)
{
  repeat (unfold /s_to_vals/).
  intro /G A B M ih S/.
  destruct /S/ /{h_nil | A' G' v_sized S h_cons}/ >> attempt (injection /h_nil/).
  injection /h_cons/ >> reintro /h_A h_G/ >> clear /h_cons/.
  reduce //.
  so /ih S/ /M_has_size M_bound/.
  exists /M_has_size/ >> auto.
  transitivity /s_size S/ >>> [exact /M_bound/, exact /plus_leq_r _# 2/, idtac] >> auto.
}
(* var *)
{
  repeat (unfold /s_to_vals/).
  intro /G A S/.
  destruct /S/ /{h_nil | A' G' v_sized S h_cons}/ >>> [injection /h_nil/, idtac].
  injection /h_cons/ >> reintro /h_A h_G/ >> clear /h_cons/.
  destruct /v_sized/ /v v_has_size/.
  reduce //.
  exists /v_has_size/.
  exact /plus_leq_l _# 2/ >> auto.
}
(* triv *)
{
  intro /G S/.
  exists /()/.
  apply /leq_0_min/.
}
(* inj1 *)
{
  auto.
}
(* inj2 *)
{
  auto.
}
(* match *)
{
  intro /G GAB GC A B C T M ih_M N1 ih_N1 N2 ih_N2 S/.
  reduce //.
  repeat (unfold /Tuple.letpair/).
  revert /N1 ih_N1 N2 ih_N2/.
  so /s_split_size G _ _ T S/ /h_S/.
  unfold /Tuple.letpair in h_S/.
  rewrite /-> h_S/ >> clear /h_S/.
  
  remember /s_split T S #1/ /subst sized_val GAB/ /SM/ /h_SM/.
  so /ih_M SM/ /M_has_size M_bound/ >> clear /ih_M/.
  revert /M_has_size M_bound/.
  remember /s_to_vals SM/ /subst tp_sem GAB/ /SM_vals/ /h_SM_vals/.
  rewrite /-> h_SM in h_SM_vals/ >>+ rewrite /-> s_split_to_vals _# 5 #1 in h_SM_vals/ >>+ clear /h_SM/.
  revert /h_SM_vals/ >>+ generalize /s_split T (s_to_vals S) #1/ /subst tp_sem GAB/ /SM_vals'/.
  intro /h_SM_vals/ >>+ subst /SM_vals'/.

  generalize /term_sem M SM_vals/ /tp_sem A % tp_sem B/ /v/ >>+ clear /M/.
  destruct /v/ /v | v/ >> reduce // >>
  andthenSeq
  [
    intro /v_has_size v_bound N1 ih_N1 N2 ih_N2/,
    first [clear /N2 ih_N2/, clear /N1 ih_N1/],
    reintro /N ih_N/,

    remember /s_split T S #2/ /subst sized_val GC/ /SN/ /h_SN/,
    so /ih_N (s_cons (v, v_has_size) SN)/ /N_has_size N_bound/ >> clear /ih_N/,
    revert /N_has_size N_bound/ >> reduce //,
    remember /s_to_vals SN/ /subst tp_sem GC/ /SN_vals/ /h_SN_vals/,
    rewrite /-> h_SN in h_SN_vals/ >>+ rewrite /-> s_split_to_vals _# 5 #2 in h_SN_vals/ >> clear /h_SN/,
    revert /h_SN_vals/ >>+ generalize /s_split T (s_to_vals S) #2/ /subst tp_sem GC/ /SN_vals'/,
    intro /h_SN_vals/ >>+ subst /SN_vals'/,

    intro /N_has_size N_bound/,
    exists /N_has_size/ >> omega
  ].
}
(* pair *)
{
  intro /G GA GB A B T M1 ih_M1 M2 ih_M2 S/.
  reduce //.
  repeat (unfold /Tuple.letpair/).
  so /s_split_size G _ _ T S/ /h_S/.
  unfold /Tuple.letpair in h_S/.
  rewrite /-> h_S/ >> clear /h_S/.
  
  remember /s_split T S #1/ /subst sized_val GA/ /SM1/ /h_SM1/.
  so /ih_M1 SM1/ /M1_has_size M1_bound/ >> clear /ih_M1/.
  revert /M1_has_size M1_bound/.
  remember /s_to_vals SM1/ /subst tp_sem GA/ /SM1_vals/ /h_SM1_vals/.
  rewrite /-> h_SM1 in h_SM1_vals/ >>+ rewrite /-> s_split_to_vals _# 5 #1 in h_SM1_vals/ >>+ clear /h_SM1/.
  revert /h_SM1_vals/ >>+ generalize /s_split T (s_to_vals S) #1/ /subst tp_sem GA/ /SM1_vals'/.
  intro /h_SM1_vals/ >>+ subst /SM1_vals'/.
  intro /M1_has_size M1_bound/.

  remember /s_split T S #2/ /subst sized_val GB/ /SM2/ /h_SM2/.
  so /ih_M2 SM2/ /M2_has_size M2_bound/ >> clear /ih_M2/.
  revert /M2_has_size M2_bound/.
  remember /s_to_vals SM2/ /subst tp_sem GB/ /SM2_vals/ /h_SM2_vals/.
  rewrite /-> h_SM2 in h_SM2_vals/ >>+ rewrite /-> s_split_to_vals _# 5 #2 in h_SM2_vals/ >>+ clear /h_SM2/.
  revert /h_SM2_vals/ >>+ generalize /s_split T (s_to_vals S) #2/ /subst tp_sem GB/ /SM2_vals'/.
  intro /h_SM2_vals/ >>+ subst /SM2_vals'/.
  intro /M2_has_size M2_bound/.

  exists /(M1_has_size, M2_has_size)/ >>+ omega.
}
(* letp *)
{
  intro /G GAB GC A B C T M ih_M N ih_N S/.
  reduce //.
  repeat (unfold /Tuple.letpair/).
  so /s_split_size G _ _ T S/ /h_S/.
  unfold /Tuple.letpair in h_S/.
  rewrite /-> h_S/ >> clear /h_S/.
  
  remember /s_split T S #1/ /subst sized_val GAB/ /SM/ /h_SM/.
  so /ih_M SM/ /M_has_size M_bound/ >> clear /ih_M/.
  revert /M_has_size M_bound/.
  remember /s_to_vals SM/ /subst tp_sem GAB/ /SM_vals/ /h_SM_vals/.
  rewrite /-> h_SM in h_SM_vals/ >>+ rewrite /-> s_split_to_vals _# 5 #1 in h_SM_vals/ >>+ clear /h_SM/.
  revert /h_SM_vals/ >>+ generalize /s_split T (s_to_vals S) #1/ /subst tp_sem GAB/ /SM_vals'/.
  intro /h_SM_vals/ >>+ subst /SM_vals'/.

  generalize /term_sem M SM_vals/ /tp_sem A & tp_sem B/ /v/ >>+ clear /M/.
  destruct /v/ /va vb/ >> intro /v_has_size/ >> destruct /v_has_size/ /va_has_size vb_has_size/ >> reduce //.
  reduce /va_has_size vb_has_size/ >> intro /v_bound/.

  remember /s_split T S #2/ /subst sized_val GC/ /SN/ /h_SN/.
  so /ih_N (s_cons (va, va_has_size) (s_cons (vb, vb_has_size) SN))/ /N_has_size N_bound/ >> clear /ih_N/.
  revert /N_has_size N_bound/ >> reduce //.
  remember /s_to_vals SN/ /subst tp_sem GC/ /SN_vals/ /h_SN_vals/.
  rewrite /-> h_SN in h_SN_vals/ >>+ rewrite /-> s_split_to_vals _# 5 #2 in h_SN_vals/.
  revert /h_SN_vals/ >>+ generalize /s_split T (s_to_vals S) #2/ /subst tp_sem GC/ /SN_vals'/. 
  intro /h_SN_vals/ >>+ subst /SN_vals'/.

  intro /N_has_size N_bound/.
  exists /N_has_size/ >>+ omega.
}
(* lam *)
{
  intro /G A B M ih_M S/.
  exists
  /
    (
      (fn va va_has_size . ih_M (s_cons (va, va_has_size) S) #1), s_size S,
      (fn va va_has_size . ih_M (s_cons (va, va_has_size) S) #2)
    )
  / >> omega.
}
(* app *)
{
  intro /G GA GB A B T M ih_M N ih_N S/.
  reduce //.
  repeat (unfold /Tuple.letpair/).
  so /s_split_size G _ _ T S/ /h_S/.
  unfold /Tuple.letpair in h_S/.
  rewrite /-> h_S/ >> clear /h_S/.
  
  remember /s_split T S #1/ /subst sized_val GA/ /SM/ /h_SM/.
  so /ih_M SM/ /M_has_size M_bound/ >> clear /ih_M/.
  revert /M_has_size M_bound/.
  remember /s_to_vals SM/ /subst tp_sem GA/ /SM_vals/ /h_SM_vals/.
  rewrite /-> h_SM in h_SM_vals/ >>+ rewrite /-> s_split_to_vals _# 5 #1 in h_SM_vals/ >>+ clear /h_SM/.
  revert /h_SM_vals/ >>+ generalize /s_split T (s_to_vals S) #1/ /subst tp_sem GA/ /SM_vals'/.
  intro /h_SM_vals/ >>+ subst /SM_vals'/.
  intro /M_has_size M_bound/.

  remember /s_split T S #2/ /subst sized_val GB/ /SN/ /h_SN/.
  so /ih_N SN/ /N_has_size N_bound/ >> clear /ih_N/.
  revert /N_has_size N_bound/.
  remember /s_to_vals SN/ /subst tp_sem GB/ /SN_vals/ /h_SN_vals/.
  rewrite /-> h_SN in h_SN_vals/ >>+ rewrite /-> s_split_to_vals _# 5 #2 in h_SN_vals/ >>+ clear /h_SN/.
  revert /h_SN_vals/ >>+ generalize /s_split T (s_to_vals S) #2/ /subst tp_sem GB/ /SN_vals'/.
  intro /h_SN_vals/ >>+ subst /SN_vals'/.
  intro /N_has_size N_bound/.
  
  destruct /M_has_size/ /M_pres M_size M_non_size_inc/.
  exists /M_pres _ N_has_size/.
  transitivity /M_size + size N_has_size/ >>> [exact /M_non_size_inc _ N_has_size/, omega].
}
(* lfold *)
{
  intro /G A M ih_M S/.
  so /ih_M S/ /M_has_size M_bound/ >> clear /ih_M/.
  revert /M_has_size M_bound/ >> reduce //.
  generalize /term_sem M (s_to_vals S)/ /_/ /v/ >> clear /M/.

  destruct /v/ /v | v/ >>> [intros >> reduce // >>+ exists /Forall_nil _/ >>+ auto, idtac].
  unfold /Tuple.letpair/ >> reduce //.
  destruct /v/ /vd v vs/ >> reduce //.
  intro /v_has_size/ >> destruct /v_has_size/ /_ v_has_size vs_has_size/.
  reduce // >> intro /v_bound/.
  exists /Forall_cons _# 3 v_has_size vs_has_size/ >>+ omega.
}
(* lrec *)
{
  intro /G A B M ih_M N ih_N S/.
  assert 
  /
    forall (M_has_size : `has_size (dlist A) (term_sem M (s_to_vals S))) . 
    exists (fold_has_size : `has_size B (term_sem (lrec M N) (s_to_vals S))) .
    `size B (term_sem (lrec M N) (s_to_vals S)) fold_has_size <= `size (dlist A) (term_sem M (s_to_vals S)) M_has_size
  /
  /fold_has_size_and_bounded/.
  {
    reduce // >> generalize /term_sem M (s_to_vals S)/ /_/ /v/ >> clear /M ih_M/.
    induction /v/.
    {
      intro /v_has_size/.
      so /ih_N (s_single (inl (), ()))/ /N_has_size N_bound/ >> clear /ih_N/.
      exists /N_has_size/ >>+ omega.
    }
    {
      intro /v vs ih cons_has_size/.
      destructThin /cons_has_size/ /{v_has_size vs_has_size}/ >>> [auto, auto, idtac].
      so /ih vs_has_size/ /fold_has_size fold_bound/.
      so /ih_N (s_single (inr ((), v, _), ((), v_has_size, fold_has_size)))/ /N_has_size N_bound/.
      exists /N_has_size/.
      transitivity /succ (size v_has_size + size fold_has_size)/ >> omega.
    }
  }
  so /ih_M S/ /M_has_size M_bound/ >> clear /ih_M/.
  so /fold_has_size_and_bounded M_has_size/ /fold_has_size fold_bound/.
  exists /fold_has_size/ >>+ omega.
}
qed ();



endModule ();