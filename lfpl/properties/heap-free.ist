openModule /Nat/;
openModule /List/;

File.import "../core/load.iml";

File.loadWithoutDependencies "size.isto";
openModule /Size/;

beginModule "HeapFree";



(* HEAP-FREE TYPE *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    heap_free : tp -> type =
    | hf_one : heap_free one
    | hf_plus : forall (A B : tp) . heap_free A -> heap_free B -> heap_free (plus A B)
    | hf_tensor : forall (A B : tp) . heap_free A -> heap_free B -> heap_free (tensor A B)
/;
Database.setImplicits (parseConstant /hf_plus/) 2;
Database.setImplicits (parseConstant /hf_tensor/) 2;



(* DUPLICATION *)

defineInd //
/
  dup : heap_free A -> forall (G : ctx) . term G A -> term G (tensor A A) of
  | hf_one . fn _ _ . pair all_right triv triv
  | hf_plus A B HA HB . fn _ M .
    match all_left M
    (
      letp all_left (dup HA _ var) 
      (
        pair (left all_right) (inj1 var) (inj1 var)
      )
    )
    (
      letp all_left (dup HB _ var) 
      (
        pair (left all_right) (inj2 var) (inj2 var)
      )
    )
  | hf_tensor A B HA HB . fn _ M .
    letp all_left M
    (
      letp (left all_right) (dup HA _ var)
      (
        letp (right (right all_left)) (dup HB _ var)
        (
          pair (right (left (right all_left)))
          (
            pair (right all_left) var var
          )
          (
            pair (right all_left) var var
          )
        )
      )
    )
//
  forall (A : tp) . heap_free A -> forall (G : ctx) . term G A -> term G (tensor A A)
/;
Database.setImplicits (parseConstant /dup/) 1;

lemma "dup_correct"
/
  forall (A : tp) (HA : heap_free A) (G : ctx) (S : subst tp_sem G) (M : term G A) .
  term_sem (dup HA G M) S = (term_sem M S, term_sem M S) : (tp_sem A & tp_sem A)
/;
intro /A HA/.
induction /HA/ >> auto.
{
  intro /G S M/.
  reduce //.
  extensionalityAuto.
}
{
  intro /A B HA ih_A HB ih_B G S M/.
  generalize /term_sem M S/ /tp_sem A % tp_sem B/ /v/. 
  andthenl (destruct /v/ /v | v/ >> reduce //) [rewrite /-> ih_A _ _ _/, rewrite /-> ih_B _ _ _/] >>
  extensionalityAuto >> reduce // >> reflexivity.
}
{
  intro /A B HA ih_A HB ih_B G S M/.
  generalize /term_sem M S/ /tp_sem A & tp_sem B/ /v/.
  destruct /v/ /v1 v2/ >> reduce //.
  andthen (rewrite /-> ih_B _ _ _/ >> reduce //) (rewrite /-> ih_A _ _ _/ >> reduce //).
  reflexivity.
}
qed ();



(* CONTRACTION *)

define /contraction {G A B} HA M/
/
  letp (left all_right) (dup HA _ var) M
//
  forall (G : ctx) (A B : tp) . heap_free A -> term (A :: A :: G) B -> term (A :: G) B
/;
withTypecheck (unfold /contraction/). qed ();

lemma "contraction_correct"
/
  forall (G : ctx) (A B : tp) (S : subst tp_sem G) (v : tp_sem A) (HA : heap_free A) (M : term (A :: A :: G) B) .
  term_sem M (s_cons v (s_cons v S)) = term_sem (contraction HA M) (s_cons v S) : tp_sem B
/;
inference.
intro /G A B s v HA M/ >> unfold /contraction/ >> reduce //.
rewrite /-> dup_correct A HA (A :: nil) (s_single v) var/ >> reduce //.
reflexivity.
qed ();



(* SIZE OF HEAP-FREE VALUES *)

lemma "heap_free_has_size"
/
  forall (A : tp) (HA : heap_free A) (v : tp_sem A) . has_size v
/;
intro /A HA/.
induction /HA/.
{
  auto.
}
{
  intro /A B HA ih_A HB ih_B v/.
  destruct /v/ /v1 | v2/ >> reduce // >> auto.
}
{
  intro /A B HA ih_A HB ih_B v/.
  destruct /v/ /v1 v2/ >> reduce // >> auto.
}
qed ();

lemma "heap_free_size_zero"
/
  forall (A : tp) (HA : heap_free A) (v : tp_sem A) (v_has_size : has_size v).
  size v_has_size = 0 : nat
/;
intro /A HA/.
induction /HA/.
{
  auto.
}
{
  intro /A B HA ih_A HB ih_B v v_has_size/.
  destruct /v/ /v1 | v2/ >> reduce // >> auto.
}
{
  intro /A B HA ih_A HB ih_B v v_has_size/.
  destruct /v/ /v1 v2/ >> reduce //.
  rewrite /-> ih_A v1 (v_has_size #1)/.
  rewrite /-> ih_B v2 (v_has_size #2)/.
  auto.
}
qed ();


lemma "heap_free_list_size_length"
/
  forall (A : tp) (HA : heap_free A) (v : tp_sem (dlist A)) (v_has_size : `has_size (dlist A) v).
  `size (dlist A) v v_has_size = length v : nat
/;
intro /A HA v/.
induction /v/.
{
  intro /nil_has_size/.
  destructThin /nil_has_size/ /{}/.
  reduce // >> reflexivity.
}
{
  intro /v vs ih cons_has_size/.
  destructThin /cons_has_size/ /{v_has_size vs_has_size}/.
  {
    auto.
  }
  {
    auto.
  }
  reduce //.
  so /heap_free_size_zero A HA v v_has_size/ /v_size_0/.
  reduce /v_size_0/.
  rewrite /-> v_size_0/.
  rewrite /-> plus_0_l _/.
  compat.
  exact /ih vs_has_size/.
}
qed ();



(* NON-LENGTH INCREASING PROPERTY *)

lemma "non_length_increasing"
/
  forall (A : tp) (HA : heap_free A) (M : term nil (arrow (dlist A) (dlist A))) (v : tp_sem (dlist A)) .
  length ((term_sem M s_nil) v) <= length v
/;
intro /A HA M v/.
assert /`has_size (dlist A) v/ /v_has_size/.
{
  reduce //.
  induction /v/ >>> [exact /Forall_nil _/, idtac].
  intro /v vs vs_has_size/ >> exact /Forall_cons _ v vs (heap_free_has_size A HA v) vs_has_size/.
}
so /size_total_and_bounded nil _ M s_nil/ /M_has_size M_bound/.
destruct /M_has_size/ /M_pres M_size M_non_size_inc/.
reduce /M_bound/ >> rewrite /-> leq_0_minimal M_size M_bound in M_non_size_inc/ >> clear /M_size M_bound/.
so /M_non_size_inc v v_has_size/ /size_Mv_le_v/ >> clear /M_non_size_inc/.
so /heap_free_list_size_length A HA v v_has_size/ /v_size_eq_length/.
so /heap_free_list_size_length A HA ((term_sem M s_nil) v) (M_pres v v_has_size)/ /Mv_size_eq_length/ >> auto.
reduce /v_size_eq_length/ >> reduce /Mv_size_eq_length/ >> reduce /size_Mv_le_v/.
rewrite /-> v_size_eq_length in size_Mv_le_v/.
rewrite /-> Mv_size_eq_length in size_Mv_le_v/.
clear /v_size_eq_length Mv_size_eq_length/.
exact /size_Mv_le_v/.
qed ();



(* HEAP-FREE COMPLETENESS *)

lemma "heap_free_surjectivity"
/
  forall (A : tp) (HA : heap_free A) (v : tp_sem A) . exists (M : term nil A) . term_sem M s_nil = v : tp_sem A
/;
intro /A HA/.
induction /HA/.
{
  intro /v/. destruct /v/ /()/.
  exists /triv/.
  reflexivity.
}
{
  intro /A B HA ih_A HB ih_B/.
  intro /(v | v)/.
  {
    clear /ih_B/. so /ih_A v/ /M h_eq/. clear /ih_A/.
    exists /inj1 M/.
    reduce //. compat. exact /h_eq/.    
  }
  {
    clear /ih_A/. so /ih_B v/ /M h_eq/. clear /ih_B/.
    exists /inj2 M/.
    reduce //. compat. exact /h_eq/.    
  }
}
{
  intro /A B HA ih_A HB ih_B/.
  intro /(va vb)/.
  so /ih_A va/ /MA h_A_eq/. clear /ih_A/.
  so /ih_B vb/ /MB h_B_eq/. clear /ih_B/.
  exists /pair all_right MA MB/.
  reduce //. auto.
}
qed ();


lemma "heap_free_function_surjectivity"
/
  forall (A : tp) (HA : heap_free A)
  (B : tp) (surjectivity : forall (v : tp_sem B) . exists (M : term nil B) . term_sem M s_nil = v : tp_sem B) 
  (f : tp_sem A -> tp_sem B) .
  exists (M : term nil (arrow A B)) . term_sem M s_nil = f : (tp_sem A -> tp_sem B)
/;
intro /A HA/.
induction /HA/ >>> [idtac, idtac, idtac, auto].
{
  intro /B surjectivity f/.
  so /surjectivity (f ())/ /M h_M/.
  exists /lam (drop M)/.
  extensionality. reintro /u/. destruct /u/ /()/.
  exact /h_M/.
}
{
  intro /A1 A2 HA1 ih1 HA2 ih2 B surjectivity f/.
  so /ih1 B surjectivity (fn x . f (inl x))/ /M1 h_M1/. clear /ih1/.
  so /ih2 B surjectivity (fn x . f (inr x))/ /M2 h_M2/. clear /ih2/.
  exists /lam (match all_left var (app all_right M1 var) (app all_right M2 var))/.
  extensionality. reintro /v/.
  (destruct /v/ /v | v/ >> reduce //) >>>
  [applyEq /fn x . x v/ /_/ /h_M1/ /_/, applyEq /fn x . x v/ /_/ /h_M2/ /_/] >> assumption.
}
{
  intro /A1 A2 HA1 ih1 HA2 ih2 B surjectivity f/.
  so /ih2 B surjectivity/ /tmp/. clear /ih2/. reintro /ih2/.
  so /ih1 (arrow A2 B) ih2/ /tmp/. clear /ih1 ih2/. reintro /ih/.
  reduce /ih/. so /ih (fn x y . f (x, y))/ /M h_M/.
  exists /lam (letp all_left var (app (left all_right) (app all_right M var) var))/.
  extensionality. reintro /v/. destruct /v/ /v1 v2/. reduce //.
  applyEq /fn x . x v1 v2/ /_/ /h_M/ /_/.
  assumption.
}
qed ();


lemma "heap_free_completeness"
/
  forall (A : tp) (HA : heap_free A) (B : tp) (HB : heap_free B) (f : tp_sem A -> tp_sem B) .
  exists (M : term nil (arrow A B)) . term_sem M s_nil = f : (tp_sem A -> tp_sem B)
/;
intro /A HA B HB/. exact /heap_free_function_surjectivity A HA B (heap_free_surjectivity B HB)/. qed ();



endModule ();