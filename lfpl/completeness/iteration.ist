openModule /Nat/;
openModule /List/;

File.import "../../math/load.iml";
File.import "../core/load-denotational.iml";
File.import "../lib/list/load.iml";

beginModule "Iteration";



(* ITERABLE FUNCTION TYPE AND LENGTH PRESERVATION *)

define /iter_tp A B/
/
  arrow (tensor A (dlist B)) (tensor A (dlist B))
//
  tp -> tp -> tp
/;
withTypecheck (unfold /iter_tp/). qed ();
setOpacity /iter_tp/ Constant.SOFT;


define /length_pres A B n V H inc f/
/
  forall (steps : nat) . V n (inc n + steps) ->
  forall (v : tp_sem A & list (tp_sem B)) . length (v #2) = n : nat ->
  H steps v -> length (f v #2) = n : nat & H (inc n + steps) (f v)
//
  forall (A B : tp) (n : nat) (V : nat -> nat -> U 0) .
  (nat -> tp_sem A & list (tp_sem B) -> U 0) ->
  (nat -> nat) -> tp_sem (iter_tp A B) -> U 0
/;
withTypecheck (unfold /length_pres/). qed ();
setOpacity /length_pres/ Constant.SOFT;


lemma "compose_length_pres"
/
  forall (A B : tp) (n : nat) (V : nat -> nat -> U 0)
  (V_leq : forall (steps1 steps2 : nat) . steps1 <= steps2 -> V n steps2 -> V n steps1)
  (H : nat -> tp_sem A & list (tp_sem B) -> U 0)
  (inc_f inc_g : nat -> nat) (f g : tp_sem (iter_tp A B)) .
  length_pres A B n V H inc_f f -> length_pres A B n V H inc_g g ->
  length_pres A B n V H (fn n . inc_g n + inc_f n) (fn x . g (f x))
/;
intro /A B n V V_leq H inc_f inc_g f g f_pres g_pres/.
intro /steps steps_valid v n_eq H_v/.
reduce /concl steps_valid H_v/.
so /f_pres steps __ v n_eq H_v/ /(len_f H_f_v)/ >>>
[apply /V_leq _ (inc_g n + inc_f n + steps)/ >>> [omega, exact /steps_valid/], idtac].
exact /g_pres (inc_f n + steps) steps_valid (f v) len_f H_f_v/ >> omega.
qed ();


lemma "nfold_length_pres"
/
  forall (A B : tp) (n : nat) (V : nat -> nat -> U 0)
  (V_leq : forall (steps1 steps2 : nat) . steps1 <= steps2 -> V n steps2 -> V n steps1)
  (H : nat -> tp_sem A & list (tp_sem B) -> U 0)
  (inc : nat -> nat) (f : tp_sem (iter_tp A B)) (k : nat) .
  length_pres A B n V H inc f ->
  length_pres A B n V H (fn n . k * inc n) (fn p . nfold p f k)
/;
reduce // >> inference.
intro /A B n V V_leq H inc f k f_pres/.
induction /k/ >>> [intro /steps/ >> auto, idtac].
intro /k ih/.
exact /compose_length_pres A B n V V_leq H (fn n . k * inc n) inc (fn p . nfold p f k) f ih f_pres/.
qed ();



(* LINEAR ITERATION *)

define /iter_helper A B M/
/
  lam
  (
    letp (left all_right) var
    (
      lrec_foldl (right (left all_right)) var
      (lam (pair (right all_left) var var))
      (
        lam
        (
          app all_right M
          (
            app (right (left all_right)) var
            (
              lcons (right (right all_left)) (right all_left) var var var
            )
          )
        )
      )
    )
  )
//
  forall (A B : tp) . term nil (iter_tp A B) ->
  term nil (arrow (tensor A (dlist B)) (arrow (dlist B) (tensor A (dlist B))))
/;
withTypecheck (unfold /iter_helper/). qed ();


lemma "iter_helper_correct"
/
  forall (A B : tp) (M : term nil (iter_tp A B)) .
  term_sem (iter_helper A B M) env_nil =
  (
    fn p l . nfold (p #1, append (p #2) l) (term_sem M env_nil) (length (p #2))
  ) : (tp_sem A & list (tp_sem B) -> list (tp_sem B) -> tp_sem A & list (tp_sem B))
/;
inference.
intro /A B M/.
unfold /iter_helper/ >> reduce //.
extensionality >> reintro /v/ >> destruct /v/ /va vbs/ >> reduce //.
rewrite /-> lrec_foldl_correct _# 10/ >> reduce //.
extensionality >> reintro /l'/ >> reduce //.
assert
/
  forall (g : tp_sem A & list (tp_sem B) -> tp_sem A & list (tp_sem B)) .
  forall (k : tp_sem A & list (tp_sem B) -> tp_sem A & list (tp_sem B)) .
  forall (h : list (tp_sem B) -> list (tp_sem B)) .
  (forall (x : tp_sem A & list (tp_sem B)) . g (k x) = k (g x) : (tp_sem A & list (tp_sem B))) ->
  `foldl
    (tp_sem B) (list (tp_sem B) -> tp_sem A & list (tp_sem B)) (fn l' . k (va , h l'))
    (fn b acc l' . g (acc (b :: l')))
    vbs l'
  = k (nfold (va, h (append vbs l')) g (length vbs)) : (tp_sem A & list (tp_sem B))
//
  strong_iter
/.
{
  inference.
  induction /vbs/ >>> [intros >> reflexivity, idtac].
  intro /vb vbs ih g k h h_comm/.
  rewrite /<- h_comm _/.
  so /ih g (fn p . g (k p)) (fn l' . h (vb :: l'))/ /ih'/ >> clear /ih/ >> reintro /ih/ >> reduce /ih/.
  apply /ih/ >> intro /x/ >>+ rewrite /-> h_comm x/ >>+ reflexivity.
}
apply /strong_iter (term_sem M env_nil) (fn p . p) (fn l' . l') __/ >> auto.
qed ();


define /iter A B M/
/
  lam
  (
    app all_left
    (
      app all_right (iter_helper A B M) var
    )
    lnil
  )
//
  forall (A B : tp) . term nil (iter_tp A B) ->
  term nil (iter_tp A B)
/;
withTypecheck (unfold /iter/). qed ();


lemma "iter_correct"
/
  forall (A B : tp) (M : term nil (iter_tp A B)) .
  term_sem (iter A B M) env_nil = (fn p . nfold p (term_sem M env_nil) (length (p #2)))
  : (tp_sem A & list (tp_sem B) -> tp_sem A & list (tp_sem B))
/;
inference.
intro /A B M/.
unfold /iter/ >> reduce //.
extensionality >> reintro /v/ >> reduce //.
rewrite /-> iter_helper_correct _# 3/ >> reduce //.
compat >> rewrite /-> append_id_r _# 2/.
extensionality >> auto.
qed ();


lemma "iter_length_pres"
/
  forall (A B : tp) (n : nat) (V : nat -> nat -> U 0)
  (V_leq : forall (steps1 steps2 : nat) . steps1 <= steps2 -> V n steps2 -> V n steps1)
  (H : nat -> tp_sem A & list (tp_sem B) -> U 0)
  (inc : nat -> nat) (M : term nil (iter_tp A B)) .
  length_pres A B n V H inc (`term_sem _ (iter_tp A B) M env_nil) ->
  length_pres A B n V H (fn n . n * inc n) (`term_sem _ (iter_tp A B) (iter A B M) env_nil)
/;
intro /A B n V V_leq H inc M M_pres/.
rewrite /-> iter_correct/.
intro /steps steps_valid v n_eq H_v/. reduce //.
so /nfold_length_pres A B n V V_leq H inc (`term_sem _ (iter_tp A B) M env_nil) n M_pres/ /loop_pres/.
reduce /loop_pres/. rewrite /-> n_eq at all/.
exact /loop_pres steps steps_valid v n_eq H_v/.
qed ();



(* COMPOSITION *)

define /compose {G GM GN A B C} T M N/
/
  lam (app (right T) M (app (right all_left) N var))
//
  forall (G GM GN : ctx) (A B C : tp) . 
  split G GM GN -> term GM (arrow B C) -> term GN (arrow A B) -> term G (arrow A C)
/;
withTypecheck (unfold /compose/). qed ();


lemma "compose_correct"
/
  forall (G GM GN : ctx) (A B C : tp) (T : split G GM GN) .
  forall (M : term GM (arrow B C)) (N : term GN (arrow A B)) (S : env G) .
  term_sem (compose T M N) S = (fn x . (term_sem M (env_split T S #1) (term_sem N (env_split T S #2) x)))
  : tp_sem (arrow A C)
/;
inference.
intro /G GM GN A B C T M N S/.
unfold /compose/ >> reduce //.
extensionality >> reintro /x/.
repeat (unfold /Tuple.letpair/).
reduce // >> reflexivity.
qed ();



(* MONOMIAL ITERATION *)

define /mono_iter A B M d c/
/
  nfold (nfold (lam var) (compose all_right M) c) (iter A B) d
//
  forall (A B : tp) . term nil (iter_tp A B) -> nat -> nat -> term nil (iter_tp A B)
/;
withTypecheck (unfold /mono_iter/ >> inference). qed ();


lemma "mono_iter_length_pres"
/
  forall (A B : tp) (n : nat) (V : nat -> nat -> U 0)
  (V_leq : forall (steps1 steps2 : nat) . steps1 <= steps2 -> V n steps2 -> V n steps1)
  (H : nat -> tp_sem A & list (tp_sem B) -> U 0)
  (M : term nil (iter_tp A B)) (d c : nat) .
  length_pres A B n V H (fn _ . 1) (`term_sem _ (iter_tp A B) M env_nil) ->
  length_pres A B n V H (fn n . c * exp n d) (`term_sem _ (iter_tp A B) (mono_iter A B M d c) env_nil)
/;
unfold /mono_iter at all/. inference.
intro /A B n V V_leq H M d c M_pres/.
induction /d/.
{
  rewrite /-> times_1_r at all/.
  induction /c/ >>> [intro /steps/ >> auto, idtac].
  intro /c ih/.
  rewrite /-> compose_correct _# 10 at all/. reduce //.
  exact /compose_length_pres A B n V V_leq H (fn _ . c) (fn _ . 1) _ (term_sem M env_nil) ih M_pres/.
}
{
  intro /d ih/.
  so /iter_length_pres A B n V V_leq H (fn n . c * exp n d) _ ih/ /goal/.
  reduce /goal/. clear /ih/.
  rewrite /(fn n . c * (n * exp n d)) = (fn n . n * (c * exp n d)) : (nat -> nat)/ >>> [idtac, exact /goal/].
  extensionality. reintro /x/. reduce //.
  rewrite /<- times_assoc, -> times_commute c x/.
  apply /times_assoc/.
}
qed ();



(* POLYNOMIAL ITERATION *)

defineInd /A B M/
/
  poly_iter : polynomial d -> term nil (arrow (tensor A (dlist B)) (tensor A (dlist B))) of
  | const c . mono_iter A B M zero c
  | monomial d c P . compose all_right (mono_iter A B M (succ d) c) (poly_iter P)
//
  forall (A B : tp) . term nil (arrow (tensor A (dlist B)) (tensor A (dlist B))) ->
  forall (d : nat) . polynomial d ->
  term nil (arrow (tensor A (dlist B)) (tensor A (dlist B)))
/;


lemma "poly_iter_length_pres"
/
  forall (A B : tp) (n : nat) (V : nat -> nat -> U 0)
  (V_leq : forall (steps1 steps2 : nat) . steps1 <= steps2 -> V n steps2 -> V n steps1)
  (H : nat -> tp_sem A & list (tp_sem B) -> U 0)
  (M : term nil (iter_tp A B)) (d : nat) (P : polynomial d) .
  length_pres A B n V H (fn _ . 1) (`term_sem _ (iter_tp A B) M env_nil) ->
  length_pres A B n V H (poly_eval P) (`term_sem _ (iter_tp A B) (poly_iter A B M d P) env_nil)
/;
intro /A B n V V_leq H M d P M_pres/.
induction /P/.
{
  intro /c/.
  so /mono_iter_length_pres A B n V V_leq H M zero c M_pres/ /goal/.
  reduce /goal/. rewrite /-> times_1_r in goal/.
  exact /goal/.
}
{
  intro /d c P ih/.
  rewrite /-> compose_correct/.
  reduce //.
  exact
  /
    compose_length_pres
      A B n V V_leq H
      (poly_eval P) (fn n . c * (n * exp n d)) _ _
      ih (mono_iter_length_pres A B n V V_leq H M (succ d) c M_pres)
  / >> reduce // >> typecheck.
}
qed ();



endModule ();