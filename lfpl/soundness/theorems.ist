openModule /Nat/;
openModule /List/;

File.import "../../math/load.iml";
File.import "../core/load-operational.iml";

File.loadWithoutDependencies "size.isto";
openModule /Size/;

File.loadWithoutDependencies "bound.isto";
openModule /PolynomialCostBound/;

beginModule "PolynomialTimeSoundness";



(* SIZE AT HEAP-FREE TYPES *)

lemma "heap_free_size_zero"
/
  forall (A : tp) (HA : heap_free A) (V : value A) . size V = 0 : nat
/;
intro /A HA/.
induction /HA/.
{
  intro /V/.
  rewrite /-> one_canonical_form V/.
  reflexivity.
}
{
  intro /A B HA A_ih HB B_ih V/.
  so /plus_canonical_form A B V/ /VA V_eq | VB V_eq/ >> subst /V/ >> reduce // >> auto.
}
{
  intro /A B HA A_ih HB B_ih V/.
  so /tensor_canonical_form A B V/ /VA VB V_eq/.
  subst /V/.
  reduce //.
  so /A_ih VA/ /VA_size/.
  so /B_ih VB/ /VB_size/.
  omega.
}
qed ();


lemma "heap_free_list_size_eq_length"
/
  forall (A : tp) (HA : heap_free A) (LV : list (value A)) . size (vlist LV) = length LV : nat
/;
intro /A HA LV/.
induction /LV/ >>> [reflexivity, idtac].
intro /V LV ih/.
rewrite /-> heap_free_size_zero A HA V/.
omega.
qed ();



(* COST BOUNDS AT HEAP-FREE TYPE *)

lemma "heap_free_value_bound_eq_zero"
/
  forall (A : tp) (HA : heap_free A) (V : value A) (n : nat) . p_eval (value_bound V) n = 0 : nat
/;
intro /A HA/.
induction /HA/.
{
  intro /V n/.
  rewrite /-> one_canonical_form V/.
  reduce //.
  unfold /p_eval/.
  reflexivity.
}
{
  intro /A B HA A_ih CB B_ih V n/.
  so /plus_canonical_form A B V/ /VA V_eq | VB V_eq/ >> subst /V/ >> reduce // >> auto.
}
{
  intro /A B HA A_ih CB B_ih V n/.
  so /tensor_canonical_form A B V/ /VA VB V_eq/.
  subst /V/.
  reduce //.
  rewrite /-> p_plus_correct/.
  so /A_ih VA n/ /A_bound/.
  so /B_ih VB n/ /B_bound/.
  omega.
}
qed ();


lemma "heap_free_list_bound_eq_zero"
/
  forall (A : tp) (HA : heap_free A) (V : value (dlist A)) (n : nat) . p_eval (value_bound V) n = 0 : nat
/;
intro /A HA V n/.
so /dlist_canonical_form A V/ /LV V_eq/.
subst /V/.
induction /LV/ >>> [unfold /p_eval/ >> reflexivity, idtac].
intro /V LV ih/.
rewrite /-> p_plus_correct at all/.
unfold /p_eval/.
rewrite /-> heap_free_value_bound_eq_zero A HA V n/.
rewrite /-> ih/.
reflexivity.
qed ();



(* CONCRETE POLYNOMIAL-TIME SOUNDNESS *)

lemma "polynomial_time_soundness"
/
  forall (A B : tp) (HA : heap_free A) (M : term (dlist A :: nil) B) (L : list (value A)) .
  exists (V : value B) (c : nat) .
  evals M (env_single (vlist L)) V c &
  c <= p_eval (term_bound M) (length L)
/;
intro /A B HA M L/.
so
/
  evals_terminates_with_polynomial_cost _# 2 M (env_single (vlist L)) (length L) __
//
  V c h_evals c_bound
/.
{
  reduce //.
  rewrite /-> heap_free_list_size_eq_length A HA L/.
  omega.
}
existses [/V/, /c/].
split >>> [exact /h_evals/, clear /h_evals/].
reduce /c_bound/.
rewrite /-> p_plus_correct in c_bound at all/.
unfold /p_eval in c_bound at 3/.
reduce /c_bound/.
rewrite /-> heap_free_list_bound_eq_zero A HA (vlist L) in c_bound/.
omega.
qed ();



endModule ();