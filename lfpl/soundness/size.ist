openModule /Nat/;
openModule /List/;

File.import "../core/load.iml";

File.loadWithoutDependencies "evaluation.isto";
openModule /Evaluation/;

beginModule "Size";



(* VALUE AND ENVIRONMENT SIZE *)

defineInd //
/
  size : value A -> nat of
  | vtriv . 0
  | vdiam . 1
  | vinj1 A B V . size V
  | vinj2 A B V . size V
  | vpair A B VA VB . size VA + size VB
  | vlam G A B S M . env_size S
  | vfold A V . size V
  and
  env_size : env G -> nat of
  | env_nil . 0
  | env_cons G A V S . size V + env_size S
//
  forall (A : tp) . value A -> nat
  and
  forall (G : ctx) . env G -> nat
/;
Database.setImplicits (parseConstant /size/) 1;
Database.setImplicits (parseConstant /env_size/) 1;


lemma "split_size"
/
  forall (G G1 G2 : ctx) (T : split G G1 G2) (S : env G) .
  env_size S = env_size (env_split T S #1) + env_size (env_split T S #2) : nat
/;
intro /G G1 G2 T/.
induction /T/ >>> [intro /G S/ >> reduce // >> reflexivity, idtac, idtac].
{
  intro /G G1 G2 A T ih S/.
  destruct /S/ /{h | A' G' V S h}/ >> injection /h/.
  unfold /Tuple.letpair at all/ >> subst /A' G'/ >> clear /h/.
  reduce //.
  rewrite /-> ih S/.
  omega.
}
{
  intro /G G1 G2 T ih S/.
  rewrite /-> ih S/.
  omega.
}
qed ();



(* NON-SIZE-INCREASING THEOREM *)

lemma "non_size_increasing"
/
  forall (G : ctx) (A : tp) (M : term G A) (S : env G) (V : value A) (c : nat) .
  evals M S V c -> size V <= env_size S
/;
intro /G A M S V c M_evals/.
induction /M_evals/.
{
  intro /G A B M S VM cM M_evals ih/.
  destruct /S/ /{h | A' G' V S h}/ >> injection /h/ >> subst /A' G'/ >> clear /h/.
  rewrite /-> ih/.
  fold /s_cons V S at all/.
  reduce //.
  omega.
}
{
  intro /G A S/.
  destruct /S/ /{h | A' G' V S h}/ >> injection /h/ >> subst /A' G'/ >> clear /h/.
  fold /s_cons V S at all/.
  reduce //.
  omega.
}
{
  intro /G S/.
  omega.
}
{
  intro /G A B M S VM cM M_evals ih/.
  exact /ih/.
}
{
  intro /G A B M S VM cM M_evals ih/.
  exact /ih/.
}
{
  intro /G GAB GC A B C T M N1 N2 S VM cM VN cN M_evals M_ih N_evals N_ih/.
  rewrite /-> N_ih/.
  rewrite /-> plus_leq _# 4 M_ih (leq_refl _)/.
  rewrite /-> split_size G GAB GC T/.
  reflexivity.
}
{
  intro /G GAB GC A B C T M N1 N2 S VM cM VN cN M_evals M_ih N_evals N_ih/.
  rewrite /-> N_ih/.
  rewrite /-> plus_leq _# 4 M_ih (leq_refl _)/.
  rewrite /-> split_size G GAB GC T/.
  reflexivity.
}
{
  intro /G GA GB A B T M1 M2 S V1 c1 V2 c2 M1_evals M1_ih M2_evals M2_ih/.
  rewrite /-> plus_leq _# 4 M1_ih M2_ih/.
  rewrite /-> split_size G GA GB T/.
  reflexivity.
}
{
  intro /G GAB GC A B C T M N S VM1 VM2 cM VN cN M_evals M_ih N_evals N_ih/.
  rewrite /-> N_ih/.
  rewrite /<- plus_assoc/.
  rewrite /-> plus_leq _# 4 M_ih (leq_refl _)/.
  rewrite /-> split_size G GAB GC T/.
  reflexivity.
}
{
  intro /G A B M S/.
  reflexivity.
}
{
  intro /G GAB GA A B T M N S G' S' M' cM VN cN V c M_evals M_ih N_evals N_ih M'_evals M'_ih/.
  rewrite /-> M'_ih/.
  rewrite /-> plus_leq _# 4 N_ih (leq_refl _)/.
  rewrite /-> plus_leq _# 4 (leq_refl _) M_ih/.
  rewrite /-> split_size G GAB GA T/.
  omega.
}
{
  intro /G A M S VM cM M_evals ih/.
  exact /ih/.
}
{
  intro /G A B M N S cM VN cN M_evals M_ih N_evals N_ih/.
  rewrite /-> N_ih/.
  omega.
}
{
  intro /G A B M N S V_head V_tail cM V_rec c_rec VN cN M_evals M_ih rec_evals rec_ih N_evals N_ih/.
  omega.
}
qed ();



endModule ();