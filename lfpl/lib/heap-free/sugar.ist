openModule /Nat/;
openModule /List/;

File.import "../../core/load-denotational.iml";

beginModule "HeapFreeSugar";



(* DUPLICATION AND CONTRACTION *)

defineInd //
/
  dup : heap_free A -> forall (G : ctx) . term G A -> term G (tensor A A) of
  | hf_one . fn _ _ . pair all_right triv triv
  | hf_plus A B HA HB . fn _ M .
    match all_left M
    (
      letp all_left (dup HA _ var) 
      (
        pair (left all_right) (inj1 var) (inj1 var)
      )
    )
    (
      letp all_left (dup HB _ var) 
      (
        pair (left all_right) (inj2 var) (inj2 var)
      )
    )
  | hf_tensor A B HA HB . fn _ M .
    letp all_left M
    (
      letp (left all_right) (dup HA _ var)
      (
        letp (right (right all_left)) (dup HB _ var)
        (
          pair (right (left (right all_left)))
          (
            pair (right all_left) var var
          )
          (
            pair (right all_left) var var
          )
        )
      )
    )
//
  forall (A : tp) . heap_free A -> forall (G : ctx) . term G A -> term G (tensor A A)
/;
Database.setImplicits (parseConstant /dup/) 1;


lemma "dup_correct"
/
  forall (A : tp) (HA : heap_free A) (G : ctx) (S : env G) (M : term G A) .
  term_sem (dup HA G M) S = (term_sem M S, term_sem M S) : (tp_sem A & tp_sem A)
/;
intro /A HA/.
induction /HA/ >> auto.
{
  intro /G S M/.
  reduce //.
  extensionalityAuto.
}
{
  intro /A B HA ih_A HB ih_B G S M/.
  generalize /term_sem M S/ /tp_sem A % tp_sem B/ /v/. 
  andthenl (destruct /v/ /v | v/ >> reduce //) [rewrite /-> ih_A _ _ _/, rewrite /-> ih_B _ _ _/] >>
  extensionalityAuto >> reduce // >> reflexivity.
}
{
  intro /A B HA ih_A HB ih_B G S M/.
  generalize /term_sem M S/ /tp_sem A & tp_sem B/ /v/.
  destruct /v/ /v1 v2/ >> reduce //.
  andthen (rewrite /-> ih_B _ _ _/ >> reduce //) (rewrite /-> ih_A _ _ _/ >> reduce //).
  reflexivity.
}
qed ();


define /contract {G A B} HA M/
/
  letp (left all_right) (dup HA _ var) M
//
  forall (G : ctx) (A B : tp) . heap_free A -> term (A :: A :: G) B -> term (A :: G) B
/;
withTypecheck (unfold /contract/). qed ();


lemma "contract_correct"
/
  forall (G : ctx) (A B : tp) (S : env G) (v : tp_sem A) (HA : heap_free A) (M : term (A :: A :: G) B) .
  term_sem M (env_cons v (env_cons v S)) = term_sem (contract HA M) (env_cons v S) : tp_sem B
/;
inference.
intro /G A B s v HA M/ >> unfold /contract/ >> reduce //.
rewrite /-> dup_correct A HA (A :: nil) (env_single v) var/ >> reduce //.
reflexivity.
qed ();



(* HEAP-FREE UPTYPE *)

lemma "heap_free_uptype"
/
  forall (A : tp) . heap_free A -> Partial.uptype (tp_sem A)
/;
intro /A HA/.
(induction /HA/ >>> [RuleTactic.unitUptype, idtac, idtac] >> intro /A B HA ih_A HB ih_B/) >>>
[RuleTactic.sumUptype, RuleTactic.prodUptype] >> auto.
qed ();



endModule ();