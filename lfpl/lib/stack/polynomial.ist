openModule /Nat/;
openModule /List/;

File.import "../../../math/load.iml";
File.import "../../core/load.iml";
File.import "../list/load.iml";
File.import "../nat/load.iml";

File.loadWithoutDependencies "interface.isto";
File.loadWithoutDependencies "base.isto";
File.loadWithoutDependencies "inductive.isto";
File.loadWithoutDependencies "additive.isto";
File.loadWithoutDependencies "weakened.isto";

openModule /Interface/;

beginModule "PolyStack";



(* MONOMIAL-BOUNDED STACK CONSTRUCTION *)

defineInd /E c/
/
  mono_stack_impl : forall (k : nat) . stack_impl E k of
  | zero . Base.base_impl E c
  | succ k . Inductive.inductive_impl E k (mono_stack_impl k)
//
  forall (E : tp) (c k : nat) . stack_impl E k
/;


lemma "mono_stack_correct"
/
  forall (E : tp) (c k : nat) . stack_correct E k (fn n . c * exp n k) (mono_stack_impl E c k)
/;
intro /E c k/. induction /k/.
{
  rewrite /-> times_1_r/.
  exact /Base.base_case_correct E c/.
}
{
  intro /k impl_correct/.
  assert /(fn n . c * (n * exp n k)) = (fn n . n * (c * exp n k)) : (nat -> nat)/ /bound_eq/.
  {
    extensionality >> reintro /n/. reduce //.
    rewrite /<- times_assoc, -> times_commute c n, -> times_assoc/.
    reflexivity.
  }
  rewrite /-> bound_eq/.
  exact /Inductive.inductive_case_correct E k (fn n . c * exp n k) _ impl_correct/.
}
qed ();



(* POLYNOMIAL-BOUNDED STACK CONSTRUCTION *)

defineInd /E/
/
  poly_stack_impl : forall (P : polynomial d) . stack_impl E d of
  | const c . Base.base_impl E c
  | monomial d c P .
    Additive.additive_impl E (succ d) (mono_stack_impl E c (succ d)) (Weakened.weakened_impl E d (poly_stack_impl P))
//
  forall (E : tp) (d : nat) (P : polynomial d) . stack_impl E d
/;


lemma "poly_stack_correct"
/
  forall (E : tp) (d : nat) (P : polynomial d) . stack_correct E d (eval P) (poly_stack_impl E d P)
/;
intro /E d P/. induction /P/ >>> [intro /c/ >> exact /Base.base_case_correct E c/, idtac].
intro /d c P ih/.
so /Weakened.weakened_correct E d _# 2 ih/ /weakened_correct/.
so /mono_stack_correct E c (succ d)/ /mono_correct/. reduce /mono_correct/.
exact /Additive.additive_correct E (succ d) _# 4 mono_correct weakened_correct/.
qed ();



endModule ();