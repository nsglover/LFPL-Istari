openModule /Nat/;
openModule /List/;

File.import "../../core/load.iml";
File.import "../nat/load.iml";

File.loadWithoutDependencies "interface.isto";
openModule /Interface/;

beginModule "Base";



(* BASE CASE IMPLEMENTATION *)

define /T E c/
/
  nfold one (fn acc . tensor (plus one E) acc) c
//
  tp -> nat -> tp
/;
withTypecheck (unfold /T/). qed ();
reductions
/
  T _ (zero) --> one ;
  T E (succ c) --> tensor (plus one E) (T E c) ;
  unfolding T
/;


defineInd /E/
/
  empty : forall (c : nat) . term nil (T E c) of
  | zero . triv
  | succ c . pair all_left (inj1 triv) (empty c)
//
  forall (E : tp) (c : nat) . term nil (T E c)
/;


defineInd /E/
/
  push : forall (c : nat) . term nil (arrow (tensor E (T E c)) (tensor (T E c) (plus E one))) of
  | zero . lam (letp all_left var (pair (right all_left) var (inj1 var)))
  | succ c .
    lam
    (
      letp all_left var
      (
        letp (right all_left) var
        (
          match (left all_right) var
          (
            letp (right all_left) (app all_right (push c) (pair (right all_left) var var))
            (
              match (right (left all_right)) var
              (pair (left (left all_right)) (pair (left all_right) (inj2 var) var) (inj2 triv))
              (pair (right all_left) (pair (right all_left) (inj1 var) var) (inj2 var))
            )
          )
          (pair (left (left all_right)) (pair (left all_right) (inj2 var) var) (inj1 var))
        )
      )
    )
//
  forall (E : tp) (c : nat) . term nil (arrow (tensor E (T E c)) (tensor (T E c) (plus E one)))
/;


defineInd /E/
/
  pop : forall (c : nat) . term nil (arrow (T E c) (tensor (T E c) (plus one E))) of
  | zero . lam (pair all_left var (inj1 triv))
  | succ c . 
    lam
    (
      letp all_left var
      (
        match (left all_right) var
        (
          letp (right all_left) (app all_right (pop c) var)
          (pair (left (right all_left)) (pair (right all_left) (inj1 var) var) var)
        )
        (pair (right all_left) (pair all_right (inj1 triv) var) (inj2 var))
      )
    )
//
  forall (E : tp) (c : nat) . term nil (arrow (T E c) (tensor (T E c) (plus one E)))
/;


define /base_impl E c/
/
  (
    T E c,
    empty E c,
    lam (lam (pair (right all_left) var (app all_right (push E c) var))),
    lam (lam (pair (right all_left) var (app all_right (pop E c) var))),
    ()
  )
//
  forall (E : tp) . nat -> stack_impl E zero
/;
withTypecheck (unfold /base_impl, stack_impl/). qed ();



(* BASE CASE CORRECTNESS *)

lemma "base_case_correct"
/
  forall (E : tp) (c : nat) . stack_correct E zero (fn _ . c) (base_impl E c)
/;
inference. unfold /stack_correct/. intro /E c/. repeatn 4 (unfold /base_impl, let/). reduce //.
induction /c/.
{
  intro /n/.
  existses [/fn _ . unit/, /fn _ . nil/, /fn _ . zero/]. reduce //.
  (* observers-correct *)
  split >>> [auto, idtac].
  (* empty-correct *)
  split >>> [unfold /stack_empty_correct/ >> reduceHard // >> auto, idtac].
  (* push-correct *)
  split.
  {
    unfold /stack_push_correct/ >> reduceHard //.
    intro /x s _/.
    existses [/s/, /inl x/].
    auto.
  }
  (* pop-correct *)
  {
    unfold /stack_pop_correct/ >> reduceHard //.
    intro /s _/.
    existses [/s/, /inl ()/].
    auto.
  }
}
{
  intro /c ih n/.
  so /ih n/ /tmp/. destruct /tmp/ /Valid Items Free observers_correct empty_correct push_correct pop_correct/.
  existses
  [
    /
      fn s . let (x, xs) = s in Valid xs &
      (
        case x of
        | inl _ . unit
        | inr _ . length (Items xs) = c : nat & Free xs = 0 : nat
      )
    /,
    /
      fn s . let (x, xs) = s in
        case x of
        | inl _ . Items xs
        | inr x . x :: Items xs
    /,
    /
      fn s . let (x, xs) = s in
        case x of
        | inl _ . succ (Free xs)
        | inr _ . zero
    /
  ]. reduce //.
  (* observers-correct *)
  split.
  {
    clear /empty_correct push_correct pop_correct/.
    unfold /stack_observers_correct in observers_correct, stack_observers_correct/.
    reduceHard /concl observers_correct/.
    intro /((u | x) s)/ >> reduceHard // >> intro /h_valid/.
    {
      so /observers_correct s (h_valid #1)/ /tmp/ >> clear /observers_correct/ >> reintro /observers_correct/.
      destruct /observers_correct/ /h_empty observers_correct/.
      split >>> [intro /h/ >> compat >> exact /h_empty h/, idtac].
      right. destruct /observers_correct/ /(h_items h_free) | (h_items (o h_free))/ >>>
      [
        split >>> [omega, exists /zero/ >> auto],
        split >>> [omega, exists /succ o/ >> auto]
      ].
    }
    split >>> [intro /h/ >> injection /h/, left >> omega].
  }
  (* empty-correct *)
  split.
  {
    clear /observers_correct push_correct pop_correct/.
    unfold /stack_empty_correct in empty_correct, stack_empty_correct/.
    reduceHard /concl empty_correct/.
    destruct /empty_correct/ /h_valid h_items h_free/. auto.
  }
  (* push-correct *)
  split.
  {
    clear /empty_correct pop_correct/.
    unfold /stack_push_correct in push_correct, stack_push_correct/.
    reduceHard /concl push_correct/.
    intro /x ((u | y) ys)/ >> reduceHard // >> intro /(h_valid h_ys_full)/ >>
    so /push_correct x ys h_valid/ /tmp/ >> clear /push_correct/ >> reintro /push_correct/ >>
    destruct /push_correct/ /s' r h_result_valid h_result h_observed/ >>
    injection /h_result/ >> clear /h_result/ >> reintro /h_m_eq h_result/ >> clear /h_m_eq/.
    {
      clear /h_ys_full/.
      rewrite /-> h_result/. clear /h_result/. reduce //.
      unfold /stack_observers_correct in observers_correct/.
      so /observers_correct ys h_valid/ /h_result/. clear /observers_correct/.
      destruct /h_result/ /_ ((h_items h_free) | (h_items (o h_free)))/.
      {
        rewrite /-> h_free in h_observed at 1/.
        destruct /h_observed/ /h_r_eq h_items_s' h_free_s'/.
        subst /r/. reduce //.
        exists /(inr x, s')/. reduce //.
        exists /inr ()/. reduce //.
        repeatn 2 (rewrite /-> h_items_s'/).
        rewrite /-> h_free_s'/.
        repeatn 2 (rewrite /-> h_free/).
        rewrite /-> h_items/. auto.
      }
      {
        revert /h_observed/. intro /h_observed/.
        rewrite /-> h_free in h_observed at 1/.
        destruct /h_observed/ /h_r_eq h_items_s' h_free_s'/.
        subst /r/. reduce //.
        exists /(inl u, s')/. reduce //.
        exists /inr ()/. reduce //.
        rewrite /-> h_free/. auto.
      }
    }
    {
      clear /h_result h_observed/.
      exists /(inr y, ys)/. reduce //.
      exists /inl x/. auto.
    }
  }
  (* pop-correct *)
  {
    clear /empty_correct push_correct/.
    unfold /stack_pop_correct in pop_correct, stack_pop_correct/.
    reduceHard /concl pop_correct/.
    intro /((u | y) ys)/ >> reduceHard // >> intro /(h_valid h_ys_full)/ >>
    so /pop_correct ys h_valid/ /tmp/ >> clear /pop_correct/ >> reintro /pop_correct/ >>
    destruct /pop_correct/ /s' r h_result_valid h_result h_observed/ >>
    injection /h_result/ >> clear /h_result/ >> reintro /h_m_eq h_result/ >> clear /h_m_eq/.
    {
      clear /h_ys_full/.
      rewrite /-> h_result/. clear /h_result/. reduce //.
      unfold /stack_observers_correct in observers_correct/.
      so /observers_correct ys h_valid/ /h_result/. clear /observers_correct/.
      destruct /h_result/ /_ ((h_items h_free) | (h_items (o h_free)))/ >> 
      (
        exists /(inl u, s')/ >> reduce // >> exists /r/ >> reduce // >>
        split >>> [auto, split >>> [auto, idtac]] >>
        revert /h_observed/ >> generalize /Items ys/ /_/ /items/ >>
        destruct /items/ /| a as/ >> reduce // >> intro /h_observed/ >>
        destruct /h_observed/ /h_r_eq h_items_s' h_free_s'/ >> auto
      ).
    }
    {
      clear /h_result h_observed/.
      exists /(inl (), ys)/. reduce //.
      exists /inr y/. reduce //.
      destruct /h_ys_full/ /(_ h_free_eq)/.
      auto.
    }
  }
}
qed ();



endModule ();