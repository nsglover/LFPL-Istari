openModule /List/;

File.import "../../../math/load.iml";
File.import "../../core/load.iml";
File.import "../list/load.iml";

beginModule "NatSugar";



(* NAT TYPE *)

define /dnat/
/
  dlist one
//
  tp
/;
withTypecheck (unfold /dnat/). qed ();
setOpacity /dnat/ Constant.SOFT;



(* NAT SEMANTICS *)

define /dnat_sem n/
/
  { l : list unit | length l = n : nat }
//
  nat -> U 0
/;
withTypecheck (unfold /dnat_sem/). qed ();


lemma "dnat_sem_sub"
/
  forall (n : nat) . dnat_sem n <: tp_sem dnat
/;
intro /n/. unfold /dnat_sem/. auto. qed ();


lemma "dnat_sem_triv"
/
  forall (n : nat) (m1 m2 : dnat_sem n) . m1 = m2 : dnat_sem n
/;
intro /n/. unfold /dnat_sem at all/. induction /n/.
{
  intro /m1 m2/. destruct /m1/ /m1 m1_len/. destruct /m2/ /m2 m2_len/.
  unhide.
  so /length_zero_form _# 2 m1 m1_len/ /m1_nil/. so /length_zero_form _# 2 m2 m2_len/ /m2_nil/.
  subst /m1/. subst /m2/. reflexivity.
}
{
  intro /n ih m1 m2/. destruct /m1/ /m1 m1_len/. destruct /m2/ /m2 m2_len/.
  unhide.
  so /length_succ_form _# 2 m1 n m1_len/ /u1 (m1' m1_eq)/. subst /m1/.
  so /length_succ_form _# 2 m2 n m2_len/ /u2 (m2' m2_eq)/. subst /m2/.
  destruct /u1/ /()/. destruct /u2/ /()/.
  reduce /m1_len m2_len/.
  injection /m1_len/. clear /m1_len/. reintro /m1_len/.
  injection /m2_len/. clear /m2_len/. reintro /m2_len/.
  so /ih m1' m2'/ /tmp/. clear /ih/. injection /tmp/. reintro /ih_eq ih_len/. unhide.
  extensionality >>> [auto, split >> reduce // >> auto].
}
qed ();


define /make_dnat n/
/
  (
    fnind make_dnat : forall (n : nat) . dnat_sem n of
    | zero . nil
    | succ n . () :: make_dnat n
  ) n
//
  forall (n : nat) . dnat_sem n
/;
unfold /make_dnat, dnat_sem at all/.
introOf /n/. sinduction /n/. reintro /ih/.
(destruct /n/ /| n/ >> reduce //) >>> [splitOf >> auto, idtac].
so /ih n (Nat.lt_succ n)/ /l/.
destructSet /l/ /ih_len/.
splitOf >>> [typecheck1 >> auto, reduce // >> compat >> unhide >> exact /ih_len/].
qed ();
reductions
/
  make_dnat (zero) --> nil ;
  make_dnat (succ n) --> () :: make_dnat n ;
  unfolding make_dnat
/;



(* ZERO AND SUCCESSOR *)

define /nzero {G}/
/
  lnil
//
  forall (G : ctx) . term G dnat
/;
withTypecheck (unfold /nzero/). qed ();
reductions
/
  term_sem _ _ (nzero _) _ --> nil ;
  unfolding nzero
/;


define /nsucc {G GM GN} T M N/
/
  lcons T all_right M triv N
//
  forall (G GM GN : ctx) . split G GM GN -> term GM diam -> term GN dnat -> term G dnat
/;
withTypecheck (unfold /nsucc/). qed ();
reductions
/
  term_sem _ _ (nsucc G GM GN T M N) S --> 
    let (_, S') = s_split tp_sem G GM GN T S in
    () :: term_sem GN (dlist one) N S' ;
  unfolding nsucc
/;



(* NAT ELIMINATION *)

define /nmatch {G GM GN A} T M N1 N2/
/
  lmatch T M N1 (drop N2)
//
  forall (G GM GN : ctx) (A : tp) .
  split G GM GN -> term GM dnat -> term GN A -> term (dnat :: diam :: GN) A ->
  term G A
/;
withTypecheck (unfold /nmatch/). qed ();


lemma "nmatch_correct"
/
  forall (G GM GN : ctx) (A : tp) (T : split G GM GN) (S : subst tp_sem G) .
  forall (M : term GM dnat) (N1 : term GN A) (N2 : term (dnat :: diam :: GN) A) . 
  term_sem (nmatch T M N1 N2) S = 
  (
    let (SM, SN) = s_split T S in
    (
      case term_sem M SM : list of
      | nil . term_sem N1 SN
      | cons v vs . term_sem N2 ((s_cons vs (s_cons () SN)))
    )
  ) : tp_sem A
/;
intro /G GM GN A T S M N1 N2/. inference.
unfold /nmatch/. rewrite /-> lmatch_correct/.
reflexivity.
qed ();


define /nrec {G GM GN A} T M N1 N2/
/
  lrec_foldr T M N1 (letp (left (left all_right)) (pair (right all_left) var var) (drop N2))
//
  forall (G GM GN : ctx) (A : tp) .
  split G GM GN -> term GM dnat -> term GN A -> term (A :: diam :: nil) A ->
  term G A
/;
withTypecheck (unfold /nrec/). qed ();


lemma "nrec_correct"
/
  forall (G GM GN : ctx) (A : tp) (T : split G GM GN) (S : subst tp_sem G) .
  forall (M : term GM dnat) (N1 : term GN A) (N2 : term (A :: diam :: nil) A) .
  term_sem (nrec T M N1 N2) S =
  (
    nfold (term_sem N1 (s_split T S #2))
    (fn acc . term_sem N2 (s_cons acc (s_cons () s_nil)))
    (length (term_sem M (s_split T S #1)))
  ) : tp_sem A
/;
intro /G GM GN A T S M N1 N2/. inference.
unfold /nrec/. reduce //.
rewrite /-> lrec_foldr_correct/.
remember /term_sem M (s_split T S #1)/ /list unit/ /l/ /l_eq/.
rewrite /<- l_eq/. clear /l_eq/.
induction /l/ >>> [reflexivity, idtac].
intro /() l ih/. repeatn 2 compat. exact /ih/.
qed ();



endModule ();