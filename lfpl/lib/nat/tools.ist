openModule /List/;

File.import "../../../math/load.iml";
File.import "../../core/load.iml";
File.import "../list/load.iml";

File.loadWithoutDependencies "sugar.isto";
openModule /NatSugar/;

beginModule "NatTools";



(* NAT SEMANTICS *)

define /dnat_sem n/
/
  { l : list unit | length l = n : nat }
//
  nat -> U 0
/;
withTypecheck (unfold /dnat_sem/). qed ();


lemma "dnat_sem_sub"
/
  forall (n : nat) . dnat_sem n <: tp_sem dnat
/;
intro /n/. unfold /dnat_sem/. auto. qed ();


lemma "dnat_sem_triv"
/
  forall (n : nat) (m1 m2 : dnat_sem n) . m1 = m2 : dnat_sem n
/;
intro /n/. unfold /dnat_sem at all/. induction /n/.
{
  intro /m1 m2/. destruct /m1/ /m1 m1_len/. destruct /m2/ /m2 m2_len/.
  unhide.
  so /length_zero_form _# 2 m1 m1_len/ /m1_nil/. so /length_zero_form _# 2 m2 m2_len/ /m2_nil/.
  subst /m1/. subst /m2/. reflexivity.
}
{
  intro /n ih m1 m2/. destruct /m1/ /m1 m1_len/. destruct /m2/ /m2 m2_len/.
  unhide.
  so /length_succ_form _# 2 m1 n m1_len/ /u1 (m1' m1_eq)/. subst /m1/.
  so /length_succ_form _# 2 m2 n m2_len/ /u2 (m2' m2_eq)/. subst /m2/.
  destruct /u1/ /()/. destruct /u2/ /()/.
  reduce /m1_len m2_len/.
  injection /m1_len/. clear /m1_len/. reintro /m1_len/.
  injection /m2_len/. clear /m2_len/. reintro /m2_len/.
  so /ih m1' m2'/ /tmp/. clear /ih/. injection /tmp/. reintro /ih_eq ih_len/. unhide.
  extensionality >>> [auto, split >> reduce // >> auto].
}
qed ();


define /make_dnat n/
/
  (
    fnind make_dnat : forall (n : nat) . dnat_sem n of
    | zero . nil
    | succ n . () :: make_dnat n
  ) n
//
  forall (n : nat) . dnat_sem n
/;
unfold /make_dnat, dnat_sem at all/.
introOf /n/. sinduction /n/. reintro /ih/.
(destruct /n/ /| n/ >> reduce //) >>> [splitOf >> auto, idtac].
so /ih n (Nat.lt_succ n)/ /l/.
destructSet /l/ /ih_len/.
splitOf >>> [typecheck1 >> auto, reduce // >> compat >> unhide >> exact /ih_len/].
qed ();
reductions
/
  make_dnat (zero) --> nil ;
  make_dnat (succ n) --> () :: make_dnat n ;
  unfolding make_dnat
/;



(* CONSTANT DIVISION *)



endModule ();