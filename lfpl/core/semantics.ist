openModule /List/;

File.load "language.isto";
File.load "substitution.isto";

openModule /Language/;
openModule /Substitution/;

beginModule "Semantics";



(* TYPE SEMANTICS *)

defineInd //
/
  tp_sem : tp -> U 0 of
  | one . unit
  | diam . unit
  | plus A B . tp_sem A % tp_sem B
  | tensor A B . tp_sem A & tp_sem B
  | arrow A B . tp_sem A -> tp_sem B
  | dlist A . list (tp_sem A)
//
  tp -> U 0
/;



(* TERM SEMANTICS *)

defineInd //
/
  term_sem : term G A -> subst tp_sem G -> tp_sem A of
  | drop G A B M . fn S .
    term_sem M (s_pop S #2)
  | var G A . fn S .
    `s_pop tp_sem _# 2 S #1
  | triv G . fn S .
    ()
  | inj1 G A B M . fn S .
    inl (term_sem M S)
  | inj2 G A B M . fn S .
    inr (term_sem M S)
  | match G GAB GC A B C T M N1 N2 . fn S .
    let (SM, SN) = s_split T S in
    case term_sem M SM of
    | inl v1 . term_sem N1 (s_cons v1 SN)
    | inr v2 . term_sem N2 (s_cons v2 SN)
  | pair G GA GB A B T M1 M2 . fn S .
    let (S1, S2) = s_split T S in
    (term_sem M1 S1, term_sem M2 S2)
  | letp G GAB GC A B C T M N . fn S .
    let (SM, SN) = s_split T S in
    let (v1, v2) = term_sem M SM in
    term_sem N (s_cons v1 (s_cons v2 SN))
  | lam G A B M . fn S .
    fn v . term_sem M (s_cons v S)
  | app G GAB GA A B T M N . fn S .
    let (SM, SN) = s_split T S in
    (term_sem M SM) (term_sem N SN)
  | lfold G A M . fn S .
    case term_sem M S of
    | inl _ . nil
    | inr c . let (v, vs) = c #2 in v :: vs
  | lrec G A B M N . fn S .
    foldr (term_sem N (s_single (inl ()))) 
    (fn v acc . term_sem N (s_single (inr ((), v, acc)))) (term_sem M S)
//
  forall (G : ctx) (A : tp) . term G A -> subst tp_sem G -> tp_sem A
/;
Database.setImplicits (parseConstant /term_sem/) 2;



endModule ();