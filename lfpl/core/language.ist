openModule /List/;

beginModule "Language";



(* TYPE *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    tp : type =
    | one : tp
    | diam : tp
    | plus : tp -> tp -> tp
    | tensor : tp -> tp -> tp
    | arrow : tp -> tp -> tp
    | dlist : tp -> tp
/;



(* CONTEXT *)

define /ctx/
/
  list tp
// 
  intersect (i : level) . U i
/;
withTypecheck (unfold /ctx/). qed ();
setOpacity /ctx/ Constant.SOFT;



(* CONTEXT SPLIT *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    split : ctx -> ctx -> ctx -> type =
    | all_right : forall (G : ctx) . split G nil G
    | left : forall (G G1 G2 : ctx) (A : tp) . split G G1 G2 -> split (A :: G) (A :: G1) G2
    | swap : forall (G G1 G2 : ctx) . split G G1 G2 -> split G G2 G1
/;
Database.setImplicits (parseConstant /all_right/) 1;
Database.setImplicits (parseConstant /left/) 4;
Database.setImplicits (parseConstant /swap/) 3;


define /all_left {G}/
/
  swap all_right
//
  forall (G : ctx) . split G G nil
/;
withTypecheck (unfold /all_left/). qed ();
setOpacity /all_left/ Constant.SOFT;


define /right {G G1 G2 A} S/
/
  swap (left (swap S))
//
  forall (G G1 G2 : ctx) (A : tp) . split G G1 G2 -> split (A :: G) G1 (A :: G2)
/;
withTypecheck (unfold /right/). qed ();
setOpacity /right/ Constant.SOFT;



(* TERM *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    term : ctx -> tp -> type =
    | drop :
        forall (G : ctx) (A B : tp) .
        term G B ->
        term (A :: G) B
    | var :
        forall (G : ctx) (A : tp) .
        term (A :: G) A
    | triv :
        forall (G : ctx) .
        term G one
    | inj1 :
        forall (G : ctx) (A B : tp) .
        term G A ->
        term G (plus A B)
    | inj2 : 
        forall (G : ctx) (A B : tp) .
        term G B ->
        term G (plus A B)
    | match : 
        forall (G GAB GC : ctx) (A B C : tp) .
        split G GAB GC -> term GAB (plus A B) -> term (A :: GC) C -> term (B :: GC) C ->
        term G C
    | pair :
        forall (G GA GB : ctx) (A B : tp) .
        split G GA GB -> term GA A -> term GB B ->
        term G (tensor A B)
    | letp :
        forall (G GAB GC : ctx) (A B C : tp) .
        split G GAB GC -> term GAB (tensor A B) -> term (A :: B :: GC) C ->
        term G C
    | lam :
        forall (G : ctx) (A B : tp) .
        term (A :: G) B ->
        term G (arrow A B)
    | app :
        forall (G GAB GA : ctx) (A B : tp) .
        split G GAB GA -> term GAB (arrow A B) -> term GA A ->
        term G B
    | lfold :
        forall (G : ctx) (A : tp) .
        term G (plus one (tensor diam (tensor A (dlist A)))) ->
        term G (dlist A)
    | lrec :
        forall (G : ctx) (A B : tp) .
        term G (dlist A) -> term (plus one (tensor diam (tensor A B)) :: nil) B ->
        term G B
/;
Database.setImplicits (parseConstant /drop/) 3;
Database.setImplicits (parseConstant /var/) 2;
Database.setImplicits (parseConstant /triv/) 1;
Database.setImplicits (parseConstant /inj1/) 3;
Database.setImplicits (parseConstant /inj2/) 3;
Database.setImplicits (parseConstant /match/) 6;
Database.setImplicits (parseConstant /pair/) 5;
Database.setImplicits (parseConstant /letp/) 6;
Database.setImplicits (parseConstant /lam/) 3;
Database.setImplicits (parseConstant /app/) 5;
Database.setImplicits (parseConstant /lfold/) 2;
Database.setImplicits (parseConstant /lrec/) 3;



(* LET SUGAR *)

define /llet {G GA GB A B} S M N/
/
  app (swap S) (lam N) M
//
  forall (G GA GB : ctx) (A B : tp) . split G GA GB -> term GA A -> term (A :: GB) B -> term G B
/;
withTypecheck (unfold /llet/). qed ();
setOpacity /llet/ Constant.SOFT;



endModule ();