openModule /Nat/;
openModule /List/;

File.loadWithoutDependencies "language.isto";
openModule /Language/;

beginModule "Operational";



(* VALUE LANGUAGE AND EVALUATION ENVIRONMENTS *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    value : tp -> type =
    | vtriv :
      value one
    | vdiam :
      value diam
    | vinj1 :
      forall (A B : tp) .
      value A ->
      value (plus A B)
    | vinj2 :
      forall (A B : tp) .
      value B ->
      value (plus A B)
    | vpair :
      forall (A B : tp) .
      value A -> value B ->
      value (tensor A B)
    | vlam :
      forall (G : ctx) (A B : tp) .
      env G -> term (A :: G) B ->
      value (arrow A B)
    | vfold :
      forall (A : tp) .
      value (plus one (tensor diam (tensor A (dlist A)))) ->
      value (dlist A)
  and
    env : ctx -> type =
    | env_nil :
      env nil
    | env_cons :
      forall (A : tp) (G : ctx) .
      value A -> env G ->
      env (A :: G)
/;
Database.setImplicits (parseConstant /vinj1/) 2;
Database.setImplicits (parseConstant /vinj2/) 2;
Database.setImplicits (parseConstant /vpair/) 2;
Database.setImplicits (parseConstant /vlam/) 3;
Database.setImplicits (parseConstant /vfold/) 1;
Database.setImplicits (parseConstant /env_cons/) 2;


define /env_single {A} V/
/
  env_cons V env_nil
//
  forall (A : tp) . value A -> env (A :: nil)
/;
withTypecheck (unfold /env_single/). qed ();
setOpacity /env_single/ Constant.SOFT;


define /env_pop {A G} S/
/
  (
    fnind case_fn : env G -> value A of
    | env_nil . Misc.bogus
    | env_cons A G V S . (V, S)
  ) (A :: G) S
//
  forall (A : tp) (G : ctx) . env (A :: G) -> value A & env G
/;
introOf /A G S/.
destruct /S/ /{h | A' G' V S h}/ >> injection /h/ >> clear /h/.
unfold /env_pop/.
typecheck.
qed ();
reductions
/
  env_pop _ _ (env_cons _ _ V S) --> (V, S) ;
  unfolding env_pop
/;


defineInd //
/
  env_split : split G G1 G2 -> env G -> env G1 & env G2 of
  | all_right _ . fn S .
    (env_nil, S)
  | left G G1 G2 A T . fn S .
    let (v, S) = env_pop S in
    (env_cons v (env_split T S #1), env_split T S #2)
  | swap G G1 G2 T . fn S .
    (env_split T S #2, env_split T S #1)
//
  forall (G G1 G2 : ctx) . split G G1 G2 -> env G -> env G1 & env G2
/;
Database.setImplicits (parseConstant /env_split/) 3;



(* CANONICAL FORM LEMMAS *)

lemma "one_canonical_form"
/
  forall (V : value one) . V = vtriv : value one
/;
intro /V/.
destruct /V/ /{h | h | C D V h | C D V h | C D VA VB h | G C D S M h | C V h}/ >> injection /h/.
reflexivity.
qed ();


lemma "diam_canonical_form"
/
  forall (V : value diam) . V = vdiam : value diam
/;
intro /V/.
destruct /V/ /{h | h | C D V h | C D V h | C D VA VB h | G C D S M h | C V h}/ >> injection /h/.
reflexivity.
qed ();


lemma "plus_canonical_form"
/
  forall (A B : tp) (V : value (plus A B)) .
  (exists (VA : value A) . V = vinj1 VA : value (plus A B)) % (exists (VB : value B) . V = vinj2 VB : value (plus A B))
/;
intro /A B V/.
(
  destruct /V/ /{h | h | C D V h | C D V h | C D VA VB h | G C D S M h | C V h}/ >>
  injection /h/ >> subst /C D/ >> clear /h/
) >>> [left, right] >> exists /V/ >> reflexivity.
qed ();


lemma "tensor_canonical_form"
/
  forall (A B : tp) (V : value (tensor A B)) .
  exists (VA : value A) (VB : value B) . V = vpair VA VB : value (tensor A B)
/;
intro /A B V/.
destruct /V/ /{h | h | C D V h | C D V h | C D VA VB h | G C D S M h | C V h}/ >>
injection /h/ >> subst /C D/ >> clear /h/.
existses [/VA/, /VB/].
reflexivity.
qed ();


lemma "arrow_canonical_form"
/
  forall (A B : tp) (V : value (arrow A B)) .
  exists (G : ctx) (M : term (A :: G) B) (S : env G) . V = vlam S M : value (arrow A B)
/;
intro /A B V/.
destruct /V/ /{h | h | C D V h | C D V h | C D VA VB h | G C D S M h | C V h}/ >>
injection /h/ >> subst /C D/ >> clear /h/.
existses [/G/, /M/, /S/].
reflexivity.
qed ();


lemma "dlist_canonical_form_fold"
/
  forall (A : tp) (V : value (dlist A)) .
  (V = vfold (vinj1 vtriv) : value (dlist A)) %
  (exists (VA : value A) (VL : value (dlist A)) . V = vfold (vinj2 (vpair vdiam (vpair VA VL))) : value (dlist A))
/;
intro /A V/.
destruct /V/ /{h | h | C D V h | C D V h | C D VA VB h | G C D S M h | C V h}/ >>
injection /h/ >> subst /C/ >> clear /h/.
destruct /V/ /{h | h | C D V h | C D V h | C D VA VB h | G C D S M h | C V h}/ >>
injection /h/ >> subst /C D/ >> clear /h/.
{
  left.
  repeatn 2 compat.
  apply /one_canonical_form/.
}
{
  right.
  destruct /V/ /{h | h | C D V h | C D V h | C D Vdiam Vcons h | G C D S M h | C V h}/ >>
  injection /h/ >> subst /C D/ >> clear /h/.
  so /tensor_canonical_form _# 2 Vcons/ /VA VL Vcons_eq/.
  subst /Vcons/.
  existses [/VA/, /VL/].
  repeatn 3 compat.
  apply /diam_canonical_form/.
}
qed ();


defineInd /A/
/
  value_list_to_value : list [(value A)] -> value (dlist A) of
  | nil . vfold (vinj1 vtriv)
  | cons V l . vfold (vinj2 (vpair vdiam (vpair V (value_list_to_value l))))
//
  forall (A : tp) . list (value A) -> value (dlist A)
/;
Database.setImplicits (parseConstant /value_list_to_value/) 1;


lemma "dlist_canonical_form"
/
  forall (A : tp) (V : value (dlist A)) . exists (l : list (value A)) . V = value_list_to_value l : value (dlist A)
/;
intro /A/.
rememberAt /dlist A/ /tp/ /0/ /B/ /B_eq/.
intro /V/.
revert /B_eq/.
sinduction /V/.
reintro /ih/.
intro /B_eq/.
destruct /V/ /{h | h | C D V h | C D V h | C D Vdiam Vcons h | G C D S M h | C V h}/ >>
rewrite /-> B_eq in h/ >> injection /h/ >> clear /h/.
reintro /C_eq/.
subst /C/ >>> [auto, idtac].
so /plus_canonical_form _# 2 V/ /Vone V_eq | Vpair Veq/ >> subst /V/.
{
  rewrite /-> one_canonical_form Vone/.
  exists /nil/.
  reflexivity.
}
{
  so /tensor_canonical_form _# 2 Vpair/ /Vdiam VC V_eq/.
  so /tensor_canonical_form _# 2 VC/ /VA VL VC_eq/.
  subst /Vpair VC/.
  so /ih (dlist A) VL __ B_eq/ /(l VL_eq)/.
  {
    apply /value_subterm_trans _# 4 __ (vfold_subterm _# 2 (vinj2 (vpair Vdiam (vpair VA VL))) #1)/ >> auto.
    apply /value_subterm_trans _# 4 __ (vinj2_subterm _# 3 (vpair Vdiam (vpair VA VL)) #1)/ >> auto.
    apply /value_subterm_trans _# 4 __ (vpair_subterm _# 4 (vpair VA VL) ## 1)/ >> auto.
    apply /vpair_subterm/. 
  }
  {
    exists /VA :: l/.
    reduce //.
    subst /VL/.
    rewrite /-> diam_canonical_form Vdiam/.
    reflexivity.
  }
}
qed ();



(* COST-AWARE EVALUATION DYNAMICS *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    evals : forall (G : ctx) (A : tp) . term G A -> env G -> value A -> nat -> type =
    | evals_drop :
      forall (G : ctx) (A B : tp) (M : term G B) (S : env (A :: G)) (VM : value B) (cM : nat) .
      evals G B M (env_pop S #2) VM cM ->
      evals (A :: G) B (drop M) S VM cM
    | evals_var :
      forall (G : ctx) (A : tp) (S : env (A :: G)) .
      evals (A :: G) A var S (env_pop S #1) zero
    | evals_triv :
      forall (G : ctx) (S : env G) .
      evals G one triv S vtriv zero
    | evals_inj1 :
      forall (G : ctx) (A B : tp) (M : term G A) (S : env G) (VM : value A) (cM : nat) .
      evals G A M S VM cM ->
      evals G (plus A B) (inj1 M) S (vinj1 VM) cM
    | evals_inj2 :
      forall (G : ctx) (A B : tp) (M : term G B) (S : env G) (VM : value B) (cM : nat) .
      evals G B M S VM cM ->
      evals G (plus A B) (inj2 M) S (vinj2 VM) cM
    | evals_match1 :
      forall (G GAB GC : ctx) (A B C : tp) (T : split G GAB GC)
      (M : term GAB (plus A B)) (N1 : term (A :: GC) C) (N2 : term (B :: GC) C)
      (S : env G) (VM : value A) (cM : nat) (VN : value C) (cN : nat) .
      evals GAB (plus A B) M (env_split T S #1) (vinj1 VM) cM ->
      evals (A :: GC) C N1 (env_cons VM (env_split T S #2)) VN cN ->
      evals G C (match T M N1 N2) S VN (1 + cM + cN)
    | evals_match2 :
      forall (G GAB GC : ctx) (A B C : tp) (T : split G GAB GC)
      (M : term GAB (plus A B)) (N1 : term (A :: GC) C) (N2 : term (B :: GC) C)
      (S : env G) (VM : value B) (cM : nat) (VN : value C) (cN : nat) .
      evals GAB (plus A B) M (env_split T S #1) (vinj2 VM) cM ->
      evals (B :: GC) C N2 (env_cons VM (env_split T S #2)) VN cN ->
      evals G C (match T M N1 N2) S VN (1 + cM + cN)
    | evals_pair :
      forall (G GA GB : ctx) (A B : tp) (T : split G GA GB)
      (M1 : term GA A) (M2 : term GB B)
      (S : env G) (V1 : value A) (c1 : nat) (V2 : value B) (c2 : nat) .
      evals GA A M1 (env_split T S #1) V1 c1 -> evals GB B M2 (env_split T S #2) V2 c2 ->
      evals G (tensor A B) (pair T M1 M2) S (vpair V1 V2) (c1 + c2)
    | evals_letp :
      forall (G GAB GC : ctx) (A B C : tp) (T : split G GAB GC)
      (M : term GAB (tensor A B)) (N : term (A :: B :: GC) C)
      (S : env G) (VM1 : value A) (VM2 : value B) (cM : nat) (VN : value C) (cN : nat) .
      evals GAB (tensor A B) M (env_split T S #1) (vpair VM1 VM2) cM ->
      evals (A :: B :: GC) C N (env_cons VM1 (env_cons VM2 (env_split T S #2))) VN cN ->
      evals G C (letp T M N) S VN (1 + cM + cN)
    | evals_lam :
      forall (G : ctx) (A B : tp) (M : term (A :: G) B) (S : env G) .
      evals G (arrow A B) (lam M) S (vlam S M) zero
    | evals_app :
      forall (G GAB GA : ctx) (A B : tp) (T : split G GAB GA)
      (M : term GAB (arrow A B)) (N : term GA A)
      (S : env G) (G' : ctx) (S' : env G') (M' : term (A :: G') B) (cM : nat) (VN : value A) (cN : nat)
      (VM' : value B) (cM' : nat) .
      evals GAB (arrow A B) M (env_split T S #1) (vlam S' M') cM ->
      evals GA A N (env_split T S #2) VN cN ->
      evals (A :: G') B M' (env_cons VN S') VM' cM' ->
      evals G B (app T M N) S VM' (1 + cM + cN + cM')
    | evals_lfold :
      forall (G : ctx) (A : tp) (M : term G (plus one (tensor diam (tensor A (dlist A))))) (S : env G)
      (VM : value (plus one (tensor diam (tensor A (dlist A))))) (cM : nat) .
      evals G (plus one (tensor diam (tensor A (dlist A)))) M S VM cM ->
      evals G (dlist A) (lfold M) S (vfold VM) cM
    | evals_lrec_nil :
      forall (G : ctx) (A B : tp) (M : term G (dlist A)) (N : term (plus one (tensor diam (tensor A B)) :: nil) B)
      (S : env G) (cM : nat) (VN : value B) (cN : nat) .
      evals G (dlist A) M S (vfold (vinj1 vtriv)) cM ->
      evals _ B N (env_single (vinj1 vtriv)) VN cN ->
      evals G B (lrec M N) S VN (1 + cM + cN)
    | evals_lrec_cons :
      forall (G : ctx) (A B : tp) (M : term G (dlist A)) (N : term (plus one (tensor diam (tensor A B)) :: nil) B)
      (S : env G) (Vhead : value A) (Vtail : value (dlist A)) (cM : nat) (Vrec : value B) (cRec : nat)
      (VN : value B) (cN : nat) .
      evals G (dlist A) M S (vfold (vinj2 (vpair vdiam (vpair Vhead Vtail)))) cM ->
      evals (dlist A :: nil) B (lrec var N) (env_single Vtail) Vrec cRec ->
      evals _ B N (env_single (vinj2 (vpair vdiam (vpair Vhead Vrec)))) VN cN ->
      evals G B (lrec M N) S VN (1 + cM + cRec + cN)
/;
Database.setImplicits (parseConstant /evals/) 2;



endModule ();