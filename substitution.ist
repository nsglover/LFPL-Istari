File.import "language-load.iml";

beginModule "Substitution";

openModule /List/;
openModule /Language/;



(* SUBSTITUTION MAP *)

define /subst P G/
/
  `Forall tp P G
//
  forall (P : tp -> U 0) . ctx -> U 0
/;
withTypecheck (unfold /subst/). qed ();
reductions
/
  subst P G --> Forall tp P G ;
  unfolding subst
/;


define /snil {P}/
/
  `Forall_nil tp P
//
  forall (P : tp -> U 0) . subst P nil
/;
withTypecheck (unfold /snil/). qed();


define /scons {P A G} v S/
/
  `Forall_cons tp P A G v S
//
  forall (P : tp -> U 0) (A : tp) (G : ctx) . P A -> subst P G -> subst P (A :: G)
/;
withTypecheck (unfold /scons/). qed();


(* SUBSTITUTION OPERATIONS *)

define /s_single {P A} v/
/
  scons v snil
//
  forall (P : tp -> U 0) (A : tp) . P A -> subst P (A :: nil)
/;
withTypecheck (unfold /s_single/). qed();
reductions
/
  s_single P A v --> scons P A nil v (snil P) ;
  unfolding s_single
/;


define /s_pop {P A G} S/
/
  (
    fnind subst_fn : Forall [tp P] G -> P A & `Forall tp P (A :: G) of
    | Forall_nil . Miscellaneous.bogus
    | Forall_cons _ _ v S . (v, S)
  ) (A :: G) S 
//
  forall (P : tp -> U 0) (A : tp) (G : ctx) .
  subst P (A :: G) -> P A & subst P G
/;
unfold /s_pop/.
introOf /P A G S/.
destruct /S/ /{h_nil | A' G' v S h_cons}/.
{
  injection /h_nil/.
}
{
  injection /h_cons/ >> reintro /h_A h_G/ >> clear /h_cons/.
  reduce //.
  auto.
}
qed ();
reductions
/
  s_pop _ _ _ (Forall_cons _ _ _ _ v S) --> (v, S) ;
  s_pop _ _ _ (scons _ _ _ v S) --> (v, S) ;
  unfolding scons s_pop
/;


defineInd /P Q/
/
  s_map : Forall [tp P] G -> (forall (A : tp) . P A -> Q A) -> subst Q G of
  | Forall_nil . fn _ . snil
  | Forall_cons _ _ v S . fn f . scons (f _ v) (s_map S f)
//
  forall (P Q : tp -> U 0) (G : ctx) .
  subst P G -> (forall (A : tp) . P A -> Q A) -> subst Q G
/;
Database.setImplicits (parseConstant /s_map/) 3;
reductions
/
  s_map P Q _ (snil _) _ --> snil Q ;
  s_map P Q _ (scons _ A G v S) f --> scons Q A G (f A v) (s_map P Q G S f) ;
  unfolding snil scons s_map
/;


defineInd /P Q/
/
  s_fold : Forall [tp P] G -> (forall (A : tp) . P A -> Q -> Q) -> Q -> Q of
  | Forall_nil . fn _ b . b
  | Forall_cons _ _ v S . fn f b . f _ v (s_fold S f b)
//
  forall (P : tp -> U 0) (Q : U 0) (G : ctx) .
  subst P G -> (forall (A : tp) . P A -> Q -> Q) -> Q -> Q
/;
Database.setImplicits (parseConstant /s_fold/) 3;
reductions
/
  s_fold _ _ _ (snil _) _ b --> b ;
  s_fold P Q _ (scons _ A G v S) f b --> f A v (s_fold P Q G S f b) ;
  unfolding snil scons s_fold
/;



(* SUBSTITUTION SPLITTING *)

defineInd /P/
/
  s_split : split G G1 G2 -> subst P G -> subst P G1 & subst P G2 of
  | all_right _ . fn S .
    (snil, S)
  | left G G1 G2 A T . fn S .
    let (v, S) = s_pop S in
    let (S1, S2) = s_split T S in
    (scons v S1, S2)
  | swap G G1 G2 T . fn S .
    let (S1, S2) = s_split T S in
    (S2, S1)
//
  forall (P : tp -> U 0) (G G1 G2 : ctx) .
  split G G1 G2 -> subst P G -> subst P G1 & subst P G2
/;
reductions
/
  s_split P _ _ _ (all_left _) S --> (S, snil P) ;
  s_split P _ _ _ (right G G1 G2 A T) S --> 
    let (v, S) = s_pop P A G S in 
    let (S1, S2) = s_split P G G1 G2 T S in
    (S1, scons P A G2 v S2) ;
  unfolding s_split Tuple.letpair
/;
Database.setImplicits (parseConstant /s_split/) 4;


endModule ();