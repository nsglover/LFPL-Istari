openModule /Nat/;

File.loadWithoutDependencies "nfold.isto";
openModule /NFold/;

File.loadWithoutDependencies "exp.isto";
openModule /Exponential/;

File.loadWithoutDependencies "binom.isto";
openModule /Binomial/;

beginModule "Polynomial";



(* DEFINITION *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    polynomial : nat -> type =
    | const : nat -> polynomial zero
    | monomial : forall (d : nat) . nat -> polynomial d -> polynomial (succ d)
/;
Database.setImplicits (parseConstant /monomial/) 1;


defineInd //
/
  poly_eval : polynomial _ -> nat -> nat of
  | const c . fn _ . c
  | monomial d c P . fn x . c * exp x (succ d) + poly_eval P x
//
  forall (d : nat) . polynomial d -> nat -> nat
/;
Database.setImplicits (parseConstant /poly_eval/) 1;


lemma "poly_eval_test"
/
  (* P(4) = 128, where P(x) = 7x^2 + 3x + 4 *)
  poly_eval (monomial 7 (monomial 3 (const 4))) 4 = 128 : nat
/;
inference. reduce //. reflexivity. qed ();



(* MONOTONICITY *)

lemma "poly_monotone"
/
  forall (d : nat) (P : polynomial d) (m n : nat) . m <= n -> poly_eval P m <= poly_eval P n
/;
intro /d P m n h_leq/.
induction /P/ >>> [auto, idtac].
intro /d c P ih/.
apply /plus_leq/ >>> [clear /ih/, exact /ih/].
apply /times_leq/ >>> [reflexivity, idtac].
apply /times_leq/ >>> [exact /h_leq/, exact /exp_base_monotone m n d h_leq/].
qed ();



(* DEGREE WEAKENING *)

defineInd /{d} P/
/
  poly_weaken_add : forall (d' : nat) . polynomial (d' + d) of
  | zero . P
  | succ d' . monomial 0 (poly_weaken_add d')
//
  forall (d : nat) (P : polynomial d) (d' : nat) . polynomial (d' + d)
/;


lemma "poly_weaken_add_correct"
/
  forall (d : nat) (P : polynomial d) (d' : nat) (n : nat) .
  poly_eval (poly_weaken_add P d') n = poly_eval P n : nat
/;
intro /d P d' n/. induction /d'/ >> auto. qed ();


define /poly_weaken {d} P d' h_leq/
/
  poly_weaken_add P (d' - d)
//
  forall (d : nat) (P : polynomial d) (d' : nat) . d <= d' -> polynomial d'
/;
withTypecheck (unfold /poly_weaken/). omega. qed ();


lemma "poly_weaken_correct"
/
  forall (d : nat) (P : polynomial d) (d' : nat) (h_leq : d <= d') (n : nat) .
  `poly_eval d' (poly_weaken P d' h_leq) n = poly_eval P n : nat
/;
intro /d P d' h_leq n/. unfold /poly_weaken/. inference.
rewrite /<- poly_weaken_add_correct d P (d' - d) n/ >>> [omega, compat >> omega].
qed ();



(* ADDITION *)


define /poly_plus_deg {d} P1 P2/
/
  (
    fnind poly_plus_deg : polynomial d -> polynomial d -> polynomial d of
    | const c1 . fn P2 .
      (
        case P2 : polynomial of
        | const c2 . const (c1 + c2)
        | monomial _ _ _ . Misc.bogus
      )
    | monomial d c1 P1 . fn P2 .
      (
        case P2 : polynomial of
        | const _ . Misc.bogus
        | monomial _ c2 P2 . monomial (c1 + c2) (poly_plus_deg P1 P2)
      )
  ) d P1 P2
//
  forall (d : nat) . polynomial d -> polynomial d -> polynomial d
/;
introOf /d/.
unfold /poly_plus_deg/.
sinduction /d/. reintro /ih/.
introOf /P1 P2/. reduce //. inference.
(destruct /P1/ /{c1 h_d1 | d1 c1 P1 h_d1}/ >> destruct /P2/ /{c2 h_d2 | d2 c2 P2 h_d2}/ >> reduce //) >>>
[typecheck, omega, omega, idtac].
reduce //. rewrite /<- h_d1 in h_d2/. injection /h_d2/. clear /h_d2/. reintro /h_d2/.
so /ih d1 __/ /tmp/ >>> [omega, clear /ih/ >> reintro /ih/].
typecheck1 >> auto.
rewrite /-> h_d2 in P2/.
inferSpine /ih/ /__ P1/ /tmp/. inferSpine /tmp/ /__ P2/ /tmp'/. clear /ih tmp/. reintro /ih/.
reduce /ih/. exact /ih/.
qed ();
reductions
/
  poly_plus_deg _ (const c1) (const c2) --> const (c1 + c2) ;
  poly_plus_deg _ (monomial d c1 P1) (monomial _ c2 P2) --> monomial d (c1 + c2) (poly_plus_deg d P1 P2) ;
  unfolding poly_plus_deg
/;


lemma "poly_plus_deg_correct"
/
  forall (d : nat) (P1 P2 : polynomial d) (n : nat) .
  poly_eval (poly_plus_deg P1 P2) n = poly_eval P1 n + poly_eval P2 n : nat
/;
inference. intro /d/.
induction /d/.
{
  intro /P1 P2 n/.
  (destruct /P1/ /{c1 h_d1 | d1 c1 P1 h_d1}/ >> destruct /P2/ /{c2 h_d2 | d2 c2 P2 h_d2}/) >>>
  [reflexivity, exfalso >> omega, exfalso >> omega, exfalso >> omega].
}
{
  intro /d ih P1 P2 n/.
  (destruct /P1/ /{c1 h_d1 | d1 c1 P1 h_d1}/ >> destruct /P2/ /{c2 h_d2 | d2 c2 P2 h_d2}/) >>>
  [exfalso >> omega, exfalso >> omega, exfalso >> omega, idtac].
  reduce //.
  injection /h_d1/. subst /d/. clear /h_d1/.
  injection /h_d2/. subst /d1/. clear /h_d2/.
  rewrite /-> ih P1 P2 n/.
  rewrite /-> times_dist_plus_l/.
  omega.
}
qed ();


define /poly_plus {d1 d2} P1 P2/
/
  poly_plus_deg (poly_weaken P1 (max d1 d2) (max_leq_l d1 d2)) (poly_weaken P2 (max d1 d2) (max_leq_r d1 d2))
//
  forall (d1 d2 : nat) . polynomial d1 -> polynomial d2 -> polynomial (max d1 d2)
/;
withTypecheck (unfold /poly_plus/). qed ();


lemma "poly_plus_correct"
/
  forall (d1 d2 : nat) (P1 : polynomial d1) (P2 : polynomial d2) (n : nat) .
  poly_eval (poly_plus P1 P2) n = poly_eval P1 n + poly_eval P2 n : nat
/;
intro /d1 d2 P1 P2 n/.
unfold /poly_plus/. inference.
rewrite /-> poly_plus_deg_correct/.
rewrite /-> poly_weaken_correct d1 P1 (max d1 d2) (max_leq_l d1 d2) n/.
rewrite /-> poly_weaken_correct d2 P2 (max d1 d2) (max_leq_r d1 d2) n/.
reflexivity.
qed ();



(* POINTWISE MAXIMUM *)

define /poly_max_deg {d} P1 P2/
/
  (
    fnind poly_max_deg : polynomial d -> polynomial d -> polynomial d of
    | const c1 . fn P2 .
      (
        case P2 : polynomial of
        | const c2 . const (max c1 c2)
        | monomial _ _ _ . Misc.bogus
      )
    | monomial d c1 P1 . fn P2 .
      (
        case P2 : polynomial of
        | const _ . Misc.bogus
        | monomial _ c2 P2 . monomial (max c1 c2) (poly_max_deg P1 P2)
      )
  ) d P1 P2
//
  forall (d : nat) . polynomial d -> polynomial d -> polynomial d
/;
introOf /d/.
unfold /poly_max_deg/.
sinduction /d/. reintro /ih/.
introOf /P1 P2/. reduce //. inference.
(destruct /P1/ /{c1 h_d1 | d1 c1 P1 h_d1}/ >> destruct /P2/ /{c2 h_d2 | d2 c2 P2 h_d2}/ >> reduce //) >>>
[typecheck, omega, omega, idtac].
reduce //. rewrite /<- h_d1 in h_d2/. injection /h_d2/. clear /h_d2/. reintro /h_d2/.
so /ih d1 __/ /tmp/ >>> [omega, clear /ih/ >> reintro /ih/].
typecheck1 >> auto.
rewrite /-> h_d2 in P2/.
inferSpine /ih/ /__ P1/ /tmp/. inferSpine /tmp/ /__ P2/ /tmp'/. clear /ih tmp/. reintro /ih/.
reduce /ih/. exact /ih/.
qed ();
reductions
/
  poly_max_deg _ (const c1) (const c2) --> const (max c1 c2) ;
  poly_max_deg _ (monomial d c1 P1) (monomial _ c2 P2) --> monomial d (max c1 c2) (poly_max_deg d P1 P2) ;
  unfolding poly_max_deg
/;


lemma "poly_max_deg_correct"
/
  forall (d : nat) (P1 P2 : polynomial d) (n : nat) .
  poly_eval P1 n <= poly_eval (poly_max_deg P1 P2) n & poly_eval P2 n <= poly_eval (poly_max_deg P1 P2) n
/;
inference. intro /d/.
induction /d/.
{
  intro /P1 P2 n/.
  (destruct /P1/ /{c1 h_d1 | d1 c1 P1 h_d1}/ >> destruct /P2/ /{c2 h_d2 | d2 c2 P2 h_d2}/) >>>
  [reduce //, exfalso, exfalso, exfalso] >> omega.
}
{
  intro /d ih P1 P2 n/.
  (destruct /P1/ /{c1 h_d1 | d1 c1 P1 h_d1}/ >> destruct /P2/ /{c2 h_d2 | d2 c2 P2 h_d2}/) >>>
  [exfalso >> omega, exfalso >> omega, exfalso >> omega, idtac].
  reduce //.
  injection /h_d1/. subst /d/. clear /h_d1/.
  injection /h_d2/. subst /d1/. clear /h_d2/.
  rewrite /-> ih P1 P2 n #1, -> ih P1 P2 n #2/.
  split >> apply /plus_leq/ >>> [apply /times_leq/ >> omega, omega].
}
qed ();


define /poly_max {d1 d2} P1 P2/
/
  poly_max_deg (poly_weaken P1 (max d1 d2) (max_leq_l d1 d2)) (poly_weaken P2 (max d1 d2) (max_leq_r d1 d2))
//
  forall (d1 d2 : nat) . polynomial d1 -> polynomial d2 -> polynomial (max d1 d2)
/;
withTypecheck (unfold /poly_max/). qed ();


lemma "poly_max_correct"
/
  forall (d1 d2 : nat) (P1 : polynomial d1) (P2 : polynomial d2) (n : nat) .
  poly_eval P1 n <= poly_eval (poly_max P1 P2) n & poly_eval P2 n <= poly_eval (poly_max P1 P2) n
/;
intro /d1 d2 P1 P2 n/.
unfold /poly_max at all/. inference.
split >>>
[
  rewrite /<- poly_weaken_correct d1 P1 (max d1 d2) (max_leq_l d1 d2) n/,
  rewrite /<- poly_weaken_correct d2 P2 (max d1 d2) (max_leq_r d1 d2) n/
] >> apply /poly_max_deg_correct/.
qed ();



(* OUTPUT SCALING *)

defineInd /k/
/
  poly_scale_out : polynomial d -> polynomial d of
  | const c . const (k * c)
  | monomial d c P . monomial (k * c) (poly_scale_out P)
//
  forall (k d : nat) . polynomial d -> polynomial d
/;


lemma "poly_scale_out_correct"
/
  forall (k d : nat) (P : polynomial d) (n : nat) . poly_eval (poly_scale_out k d P) n = k * (poly_eval P n) : nat
/;
intro /k d P n/.
induction /P/ >>> [auto, idtac].
intro /d c P ih/.
rewrite /-> ih/. clear /ih/.
rewrite /-> times_dist_plus_r/.
rewrite /-> times_assoc/.
reflexivity.
qed ();



(* OUTPUT DEGREE SHIFTING *)

defineInd //
/
  poly_deg_shift : polynomial d -> polynomial (succ d) of
  | const c . monomial c (const 0)
  | monomial d c P . monomial c (poly_deg_shift P)
//
  forall (d : nat) . polynomial d -> polynomial (succ d)
/;
Database.setImplicits (parseConstant /poly_deg_shift/) 1;


lemma "poly_deg_shift_correct"
/
  forall (d : nat) (P : polynomial d) (n : nat) . poly_eval (poly_deg_shift P) n = n * poly_eval P n : nat
/;
intro /d P n/.
induction /P/.
{
  intro /c/.
  rewrite /-> times_1_r/.
  rewrite /-> times_commute/.
  omega.
}
{
  intro /d c P ih/.
  rewrite /-> ih/.
  rewrite /-> times_dist_plus_r/.
  compat.
  rewrite /<- times_assoc, -> times_commute c n, -> times_assoc/.
  reflexivity.
}
qed ();



(* INPUT SHIFTING *)

defineInd /n/
/
  poly_binom : forall (d : nat) . polynomial d of
  | zero . const 1
  | succ d . monomial (binom n (succ d)) (poly_binom d)
//
  forall (n d : nat) . polynomial d
/;


define /mono_shift d c/
/
  poly_scale_out c d (poly_binom d d)
//
  forall (d c : nat) . polynomial d
/;
withTypecheck (unfold /mono_shift/). qed ();


lemma "mono_shift_correct"
/
  forall (d c n : nat) . poly_eval (mono_shift d c) n = c * exp (succ n) d : nat
/;
intro /d c m/. unfold /mono_shift/.
rewrite /-> poly_scale_out_correct/. compat.
rememberAt /d/ /_/ /1 3/ /n/ /n_eq/.
assert /poly_eval (poly_binom n d) m = indexed plus (fn k . binom n k * exp m k) d : nat/ /tmp/.
{
  clear /n_eq/.
  induction /d/ >>> [rewrite /-> binom_zero/ >> reflexivity, idtac].
  intro /d ih/.
  rewrite /-> plus_commute, -> ih/.
  reflexivity.
}
rewrite /-> tmp/. clear /tmp/. subst /n/.
symmetry. exact /binomial_thm _# 2/.
qed ();


defineInd //
/
  poly_shift : polynomial d -> polynomial d of
  | const c . const c
  | monomial d c P . poly_plus (mono_shift (succ d) c) (poly_shift P)
//
  forall (d : nat) . polynomial d -> polynomial d
/;
omega. qed ();
Database.setImplicits (parseConstant /poly_shift/) 1;


lemma "poly_shift_correct"
/
  forall (d : nat) (P : polynomial d) (n : nat) . poly_eval (poly_shift P) n = poly_eval P (succ n) : nat
/;
intro /d P n/. inference.
induction /P/ >>> [auto, idtac].
intro /d c P ih/.
transitivity /_/.
{
  forceExact /poly_plus_correct _# 2 (mono_shift (succ d) c) (poly_shift P) n/.
  typecheck. compat. omega.
}
rewrite /-> ih/. clear /ih/.
rewrite /-> mono_shift_correct/.
reflexivity.
qed ();



(* INPUT SCALING *)

defineInd /k/
/
  poly_scale_in : polynomial d -> polynomial d of
  | const c . const c
  | monomial d c P . monomial (exp k (succ d) * c) (poly_scale_in P)
//
  forall (k d : nat) . polynomial d -> polynomial d
/;


lemma "poly_scale_in_correct"
/
  forall (k d : nat) (P : polynomial d) (n : nat) . poly_eval (poly_scale_in k d P) n = poly_eval P (k * n) : nat
/;
intro /k d P n/.
induction /P/ >>> [auto, idtac].
intro /d c P ih/.
rewrite /-> ih/. clear /ih/.
compat.
rewrite /<- times_assoc c _ _/.
rewrite /-> times_commute _ c/.
rewrite /-> times_assoc/.
rewrite /<- times_assoc _ n _/.
rewrite /-> times_assoc _ _ n/.
rewrite /-> times_commute _ n/.
rewrite /<- times_assoc _ n _/.
rewrite /-> times_assoc/.
rewrite /<- times_assoc _ (k * n) _/.
compat. symmetry. exact /exp_base_times _# 3/.
qed ();



(* DEGREE-AGNOSTIC POLYNOMIALS *)

define /p_eval P/
/
  `poly_eval (P #1) (P #2)
//
  (exists (d : nat) . polynomial d) -> nat -> nat
/;
withTypecheck (unfold /p_eval/). qed ();


define /p_zero/
/
  (0, const 0)
//
  (exists (d : nat) . polynomial d)
/;
withTypecheck (unfold /p_zero/). qed ();
setOpacity /p_zero/ Constant.SOFT;


define /p_one/
/
  (0, const 1)
//
  (exists (d : nat) . polynomial d)
/;
withTypecheck (unfold /p_one/). qed ();
setOpacity /p_one/ Constant.SOFT;


define /p_plus P Q/
/
  let (dP, P) = P in
  let (dQ, Q) = Q in
  (max dP dQ, poly_plus P Q)
//
  (exists (d : nat) . polynomial d) -> (exists (d : nat) . polynomial d) -> (exists (d : nat) . polynomial d)
/;
introOf /(dP P) (dQ Q)/.
unfold /p_plus/.
typecheck.
qed ();


lemma "p_plus_correct"
/
  forall (P Q : (exists (d : nat) . polynomial d)) (n : nat) .
  p_eval (p_plus P Q) n = p_eval P n + p_eval Q n : nat
/;
intro /(dP P) (dQ Q) n/.
unfold /p_eval at all, p_plus at all/.
apply /poly_plus_correct/.
qed ();


define /p_max P Q/
/
  let (dP, P) = P in
  let (dQ, Q) = Q in
  (max dP dQ, poly_max P Q)
//
  (exists (d : nat) . polynomial d) -> (exists (d : nat) . polynomial d) -> (exists (d : nat) . polynomial d)
/;
introOf /(dP P) (dQ Q)/.
unfold /p_max/.
typecheck.
qed ();


lemma "p_max_correct"
/
  forall (P Q : (exists (d : nat) . polynomial d)) (n : nat) .
  p_eval P n <= p_eval (p_max P Q) n & p_eval Q n <= p_eval (p_max P Q) n
/;
intro /(dP P) (dQ Q) n/.
unfold /p_eval at all, p_max at all/.
reduce //.
apply /poly_max_correct/.
qed ();


define /p_shift P/
/
  let (d, P) = P in
  (succ d, poly_deg_shift P)
//
  (exists (d : nat) . polynomial d) -> (exists (d : nat) . polynomial d)
/;
introOf /(d P)/.
unfold /p_shift/.
typecheck.
qed ();


lemma "p_shift_correct"
/
  forall (P : exists (d : nat) . polynomial d) (n : nat) .
  p_eval (p_shift P) n = n * p_eval P n : nat
/;
intro /(d P) n/.
unfold /p_eval at all, p_shift at all/.
reduce //.
apply /poly_deg_shift_correct/.
qed ();



endModule ();