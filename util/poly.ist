openModule /Nat/;

File.load "nfold.isto";

openModule /NFold/;

beginModule "Polynomial";



(* EXPONENTIATION *)

defineInd /m/
/
  exp : nat -> nat of
  | zero . 1
  | succ n . m * exp n
//
  nat -> nat -> nat
/;


lemma "exp_test"
/
  exp 3 4 = 81 : nat
/;
inference.
unfold /exp/.
reduce //.
reflexivity.
qed ();



(* POLYNOMIAL *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    polynomial : nat -> type =
    | const : nat -> polynomial zero
    | monomial : forall (d : nat) . nat -> polynomial d -> polynomial (succ d)
/;
Database.setImplicits (parseConstant /monomial/) 1;


defineInd //
/
  eval : polynomial n -> nat -> nat of
  | const c . fn _ . c
  | monomial d c P . fn x . c * exp x (succ d) + eval P x
//
  forall (n : nat) . polynomial n -> nat -> nat
/;
Database.setImplicits (parseConstant /eval/) 1;

lemma "eval_test"
/
  (* P(4) = 128, where P(x) = 7x^2 + 3x + 4 *)
  eval (monomial 7 (monomial 3 (const 4))) 4 = 128 : nat
/;
inference.
unfold /eval/.
reduce //.
reflexivity.
qed ();



(* TODO: Move or get rid of this *)

(* BIT AND BIT VECTOR *)

define /bit/
/
  unit % unit
//
  U 0
/;
withTypecheck (unfold /bit/). qed ();
setOpacity /bit/ Constant.SOFT;


define /bitvec n/
/
  nfold unit (fn acc . bit & acc) n
//
  nat -> U 0
/;
withTypecheck (unfold /bitvec/). qed ();
reductions
/
  bitvec (zero) --> unit ;
  bitvec (succ n) --> bit & bitvec n ;
  unfolding bitvec
/;



endModule ();