File.loadWithoutDependencies "tape.isto";
openModule /Tape/;

beginModule "Transition";



(* MACHINE STATE *)

define /state q/
/
  unit % q
//
  intersect (i : level) . U i -> U i
/;
withTypecheck (unfold /state/). qed ();
setOpacity /state/ Constant.SOFT;


define /halt_state/
/
  inl ()
//
  intersect (i : level) (q : U i) . state q
/;
withTypecheck (unfold /halt_state/). qed ();


define /new_state x/
/
  inr x
//
  intersect (i : level) (q : U i) . q -> state q
/;
withTypecheck (unfold /new_state/). qed ();


define /config a q/
/
  state q & tape a
//
  intersect (i : level) . U i -> U i -> U i
/;
withTypecheck (unfold /config/). qed ();
setOpacity /config/ Constant.SOFT;



(* TRANSITION FUNCTION *)

define /transition q a/
/
  q -> symbol a -> state q & symbol a & (unit % unit)
//
  intersect (i : level) . U i -> U i -> U i
/;
withTypecheck (unfold /transition/). qed ();
setOpacity /transition/ Constant.SOFT_STRICT;


define /step tr p/
/
  let (C, T) = p in
  let (C', instr) = tr C (tape_head T) in
  let (x, dir) = instr in
  (C', tape_shift dir (tape_write x T))
//
  intersect (i : level) (q a : U i) . transition q a -> q & tape a -> config a q
/;
withTypecheck (unfold /step/). qed ();


define /step_total tr p/
/
  let (C, T) = p in
  case C of
  | inl _ . (inl (), T)
  | inr C . step tr (C, T)
//
  intersect (i : level) (q a : U i) . transition q a -> config a q -> config a q
/;
withTypecheck (unfold /step_total/). qed ();



endModule ();