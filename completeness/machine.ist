openModule /Nat/;
openModule /List/;

File.import "../util/util-load.iml";

beginModule "Machine";



(* TAPE SYMBOL *)

define /symbol/
/
  bit
//
  intersect (i : level) . U i
/;
withTypecheck (unfold /symbol/). qed ();
setOpacity /symbol/ Constant.SOFT;


define /symbol_default/
/
  inl ()
//
  symbol
/;
withTypecheck (unfold /symbol, symbol_default/). qed ();
setOpacity /symbol_default/ Constant.SOFT;



(* TAPE *)

define /tape/
/
  list symbol & symbol & list symbol
//
  intersect (i : level) . U i
/;
withTypecheck (unfold /tape/). qed ();
setOpacity /tape/ Constant.SOFT;


define /tape_left T/
/
  T #1
//
  tape -> list symbol
/;
withTypecheck (unfold /tape_left/). qed ();
setOpacity /tape_left/ Constant.SOFT;


define /tape_head T/
/
  T #2 #1
//
  tape -> symbol
/;
withTypecheck (unfold /tape_head/). qed ();
setOpacity /tape_head/ Constant.SOFT;


define /tape_right T/
/
  T #2 #2
//
  tape -> list symbol
/;
withTypecheck (unfold /tape_right/). qed ();
setOpacity /tape_right/ Constant.SOFT;


define /tape_init input/
/
  (nil, symbol_default, input)
//
  list symbol -> tape
/;
withTypecheck (unfold /tape_init/). qed ();
setOpacity /tape_init/ Constant.SOFT;


define /tape_write x T/
/
  (tape_left T, x, tape_right T)
//
  symbol -> tape -> tape
/;
withTypecheck (unfold /tape_write/). qed ();
setOpacity /tape_write/ Constant.SOFT;


define /dir/
/
  bit
//
  intersect (i : level) . U i
/;
withTypecheck (unfold /dir/). qed ();
setOpacity /dir/ Constant.SOFT;


define /tape_shift d T/
/
  let (l, xr) = T in
  let (x, r) = xr in
  case d of
  | inl _ .
    case l : list of
    | nil . (nil, symbol_default, x :: r)
    | cons y l . (l, y, x :: r)
  | inr _ .
    case r : list of
    | nil . (x :: l, symbol_default, nil)
    | cons y r . (x :: l, y, r)
//
  dir -> tape -> tape
/;
withTypecheck (unfold /tape_shift/). qed ();


define /tape_size T/
/
  succ (length (tape_left T) + length (tape_right T))
//
  tape -> nat
/;
withTypecheck (unfold /tape_size/). qed ();
setOpacity /tape_size/ Constant.SOFT;



(* TURING MACHINE *)

define /state n/
/
  bitvec n & tape
//
  intersect (i : level) . nat -> U i
/;
withTypecheck (unfold /state/). qed ();
setOpacity /state/ Constant.SOFT;


define /machine n/
/
  bitvec n & (bitvec n -> symbol -> dir & bitvec n & symbol)
//
  intersect (i : level) . nat -> U i
/;
withTypecheck (unfold /machine/). qed ();


define /machine_transition {n} M/
/
  M #2
//
  forall (n : nat) . machine n -> (bitvec n -> symbol -> dir & bitvec n & symbol)
/;
withTypecheck (unfold /machine_transition, machine/). qed ();


define /machine_init_state {n} M input/
/
  (M #1, tape_init input)
//
  forall (n : nat) . machine n -> list symbol -> state n
/;
withTypecheck (unfold /machine_init_state, machine/). qed ();


define /step_machine {n} M S/
/
  let (C, T) = S in
  let (d, instr) = (machine_transition M) C (tape_head T) in
  let (C', x) = instr in
  (C', tape_shift d (tape_write x T))
//
  forall (n : nat) . machine n -> state n -> state n
/;
withTypecheck (unfold /step_machine/). qed ();


define /run_machine {n} M input steps/
/
  nfold (machine_init_state M input) (step_machine M) steps
//
  forall (n : nat) . machine n -> list symbol -> nat -> state n
/;
withTypecheck (unfold /run_machine/). qed ();


define /run_ptime_machine {n d} P M input/
/
  run_machine M input (eval P (length input)) #2 #1
//
  forall (n d : nat) . polynomial d -> machine n -> (list symbol -> list symbol)
/;
withTypecheck (unfold /run_ptime_machine/). qed ();



endModule ();