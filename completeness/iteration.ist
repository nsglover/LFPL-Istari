openModule /Nat/;
openModule /List/;

File.import "../core/core-load.iml";
File.import "../tools/tools-load.iml";
File.import "../util/util-load.iml";

beginModule "Iteration";



(* ITERATION *)

(* TODO: Do Jan's more general version where (l, f) -> (l, f^|l|) *)

define /iter_helper A B M/
/
  lam
  (
    letp (left all_right) var
    (
      lrec_foldl (right (left all_right)) var
      (lam (pair (right all_left) var var))
      (
        lam
        (
          app all_right M
          (
            app (right (left all_right)) var
            (
              lcons (right (right all_left)) (right all_left) var var var
            )
          )
        )
      )
    )
  )
//
  forall (A B : tp) . term nil (arrow (tensor A (dlist B)) (tensor A (dlist B))) ->
  term nil (arrow (tensor A (dlist B)) (arrow (dlist B) (tensor A (dlist B))))
/;
withTypecheck (unfold /iter_helper/). qed ();

lemma "iter_helper_correctness"
/
  forall (A B : tp) (M : term nil (arrow (tensor A (dlist B)) (tensor A (dlist B)))) .
  term_sem (iter_helper A B M) s_nil =
  (
    fn p l . nfold (p #1, append (p #2) l) (term_sem M s_nil) (length (p #2))
  ) : (tp_sem A & list (tp_sem B) -> list (tp_sem B) -> tp_sem A & list (tp_sem B))
/;
inference.
intro /A B M/.
unfold /iter_helper/ >> reduce //.
extensionality >> reintro /v/ >> destruct /v/ /va vbs/ >> reduce //.
rewrite /-> lrec_foldl_correctness _# 10/ >> reduce //.
extensionality >> reintro /l'/ >> reduce //.
assert
/
  forall (g : tp_sem A & list (tp_sem B) -> tp_sem A & list (tp_sem B)) .
  forall (k : tp_sem A & list (tp_sem B) -> tp_sem A & list (tp_sem B)) .
  forall (h : list (tp_sem B) -> list (tp_sem B)) .
  (forall (x : tp_sem A & list (tp_sem B)) . g (k x) = k (g x) : (tp_sem A & list (tp_sem B))) ->
  `foldl
    (tp_sem B) (list (tp_sem B) -> tp_sem A & list (tp_sem B)) (fn l' . k (va , h l'))
    (fn b acc l' . g (acc (b :: l')))
    vbs l'
  = k (nfold (va, h (append vbs l')) g (length vbs)) : (tp_sem A & list (tp_sem B))
//
  strong_iter
/.
{
  inference.
  induction /vbs/ >>> [intros >> reflexivity, idtac].
  intro /vb vbs ih g k h h_comm/.
  rewrite /<- h_comm _/.
  so /ih g (fn p . g (k p)) (fn l' . h (vb :: l'))/ /ih'/ >> clear /ih/ >> reintro /ih/ >> reduce /ih/.
  apply /ih/ >> intro /x/ >>+ rewrite /-> h_comm x/ >>+ reflexivity.
}
apply /strong_iter (term_sem M s_nil) (fn p . p) (fn l' . l') __/ >> auto.
qed ();


define /iter A B M/
/
  lam
  (
    app all_left
    (
      app all_right (iter_helper A B M) var
    )
    lnil
  )
//
  forall (A B : tp) . term nil (arrow (tensor A (dlist B)) (tensor A (dlist B))) ->
  term nil (arrow (tensor A (dlist B)) (tensor A (dlist B)))
/;
withTypecheck (unfold /iter/). qed ();

lemma "iter_correctness"
/
  forall (A B : tp) (M : term nil (arrow (tensor A (dlist B)) (tensor A (dlist B)))) .
  term_sem (iter A B M) s_nil = (fn p . nfold p (term_sem M s_nil) (length (p #2)))
  : (tp_sem A & list (tp_sem B) -> tp_sem A & list (tp_sem B))
/;
inference.
intro /A B M/.
unfold /iter/ >> reduce //.
extensionality >> reintro /v/ >> reduce //.
rewrite /-> iter_helper_correctness _# 3/ >> reduce //.
compat >> rewrite /-> append_id_r _# 2/.
extensionality >> auto.
qed ();



(* COMPOSITION *)

define /compose {G GM GN A B C} T M N/
/
  lam (app (right T) M (app (right all_left) N var))
//
  forall (G GM GN : ctx) (A B C : tp) . 
  split G GM GN -> term GM (arrow B C) -> term GN (arrow A B) -> term G (arrow A C)
/;
withTypecheck (unfold /compose/). qed ();

lemma "compose_correctness"
/
  forall (G GM GN : ctx) (A B C : tp) (T : split G GM GN) .
  forall (M : term GM (arrow B C)) (N : term GN (arrow A B)) (S : subst tp_sem G) .
  term_sem (compose T M N) S = (fn x . (term_sem M (s_split T S #1) (term_sem N (s_split T S #2) x)))
  : tp_sem (arrow A C)
/;
inference.
intro /G GM GN A B C T M N S/.
unfold /compose/ >> reduce //.
extensionality >> reintro /x/.
repeat (unfold /Tuple.letpair/).
reduce // >> reflexivity.
qed ();



(* POLYNOMIAL ITERATION *)

define /iter_tp A B/
/
  arrow (tensor A (dlist B)) (tensor A (dlist B))
//
  tp -> tp -> tp
/;
withTypecheck (unfold /iter_tp/). qed ();
reductions
/
  tp_sem (iter_tp A B) --> tp_sem A & tp_sem (dlist B) -> tp_sem A & tp_sem (dlist B) ;
  unfolding iter_tp
/;
setOpacity /iter_tp/ Constant.SOFT;


define /length_pres A B f/
/
  forall (p : tp_sem A & list (tp_sem B)) . length (f p #2) = length (p #2) : nat
//
  intersect (i : level) . forall (A B : tp) . (tp_sem (iter_tp A B)) -> U i
/;
withTypecheck (unfold /length_pres/). qed ();
setOpacity /length_pres/ Constant.SOFT;


lemma "nfold_length_pres"
/
  forall (A B : tp) (f : tp_sem (iter_tp A B)) (n : nat) .
  length_pres A B f -> length_pres A B (fn p . `nfold (tp_sem A & list (tp_sem B)) p f n)
/;
reduce // >> inference.
intro /A B f n h_length_pres/.
induction /n/ >>> [intros >> reflexivity, idtac].
intro /n ih p/.
rewrite /-> h_length_pres _/.
exact /ih p/.
qed ();


define /mono_iter A B M d c/
/
  nfold (nfold (lam var) (compose all_right M) c) (iter A B) d
//
  forall (A B : tp) . term nil (iter_tp A B) -> nat -> nat -> term nil (iter_tp A B)
/;
withTypecheck (unfold /mono_iter/ >> inference). qed ();

lemma "mono_iter_correctness"
/
  forall (A B : tp) (M : term nil (iter_tp A B)) (d c : nat) .
  length_pres A B (`term_sem nil (iter_tp A B) M s_nil) ->
  term_sem (mono_iter A B M d c) s_nil = (fn p . nfold p (term_sem M s_nil) (c * exp (length (p #2)) d)) : _
/;
unfold /mono_iter/ >> inference.
intro /A B M d c h_length_pres/.
induction /d/.
{
  extensionality >> reintro /p/ >> reduce //.
  induction /c/ >>> [reflexivity, idtac].
  intro /c ih/.
  rewrite /-> compose_correctness _# 10/ >> reduce // >> compat.
  exact /ih/.
}
{
  intro /d ih/.
  extensionality >> reintro /p/ >> destruct /p/ /x l/ >> reduce //.
  rewrite /-> iter_correctness _# 3/ >> reduce //.
  rewrite /-> ih/ >> clear /ih/.
  rewrite
  /
    nfold (x, l) (fn p . nfold p (term_sem M s_nil) (c * exp (length (p #2)) d)) (length l) =
    (nfold (x, l) (fn p . nfold p (term_sem M s_nil) (c * exp (length l) d)) (length l))
    : (tp_sem A & list (tp_sem B))
  /.
  {
    inference.
    generalizeAt /length l/ /nat/ /0 2/ /n/.
    induction /n/ >>> [reflexivity, idtac].
    intro /n ih/.
    compat >>> [exact /ih/, idtac].
    repeatn 2 compat.
    rewrite /-> ih/.
    apply /nfold_length_pres _# 4 __/.
    exact /nfold_length_pres _# 4 h_length_pres/.
  }
  rewrite /-> nfold_times _# 2 (term_sem M s_nil) _# 2/.
  compat >> rewrite /-> times_commute (length l) _/ >> exact /times_assoc _# 3/.
}
qed ();


lemma "mono_iter_length_pres"
/
  forall (A B : tp) (M : term nil (iter_tp A B)) (d c : nat) .
  length_pres A B (`term_sem nil (iter_tp A B) M s_nil) ->
  length_pres A B (`term_sem nil (iter_tp A B) (mono_iter A B M d c) s_nil)
/;
unfold /mono_iter/.
intro /A B M d c h_length_pres/.
induction /d/.
{
  intro /p/.
  induction /c/ >>> [reflexivity, idtac].
  intro /c ih/.
  rewrite /-> compose_correctness _# 10/ >> reduce //.
  rewrite /-> h_length_pres _/ >> exact /ih/.
}
{
  intro /d ih p/.
  rewrite /-> iter_correctness _# 3/ >> reduce //.
  apply /nfold_length_pres _# 4 ih/.
}
qed ();


defineInd /A B M/
/
  poly_iter : polynomial d -> term nil (arrow (tensor A (dlist B)) (tensor A (dlist B))) of
  | const c . mono_iter A B M zero c
  | monomial d c P . compose all_right (mono_iter A B M (succ d) c) (poly_iter P)
//
  forall (A B : tp) . term nil (arrow (tensor A (dlist B)) (tensor A (dlist B))) ->
  forall (d : nat) . polynomial d ->
  term nil (arrow (tensor A (dlist B)) (tensor A (dlist B)))
/;


lemma "poly_iter_length_pres"
/
  forall (A B : tp) (M : term nil (iter_tp A B)) (d : nat) (P : polynomial d) .
  length_pres A B (`term_sem nil (iter_tp A B) M s_nil) ->
  length_pres A B (`term_sem nil (iter_tp A B) (poly_iter A B M d P) s_nil)
/;
intro /A B M d P h_length_pres/.
induction /P/.
{
  intro /c/.
  exact /mono_iter_length_pres _# 5 h_length_pres/.
}
{
  intro /d c P ih/.
  rewrite /-> compose_correctness _# 10/ >> reduce //.
  rewrite /-> mono_iter_correctness _# 5 h_length_pres/ >> reduce //.
  intro /p/ >> reduce //.
  rewrite /-> ih p at all/.
  rewrite /-> nfold_length_pres _# 4 h_length_pres _/.
  exact /ih p/.
}
qed ();


lemma "poly_iter_correctness"
/
  forall (A B : tp) (M : term nil (iter_tp A B)) (d : nat) (P : polynomial d) .
  length_pres A B (`term_sem nil (iter_tp A B) M s_nil) ->
  term_sem (poly_iter A B M d P) s_nil = (fn p . nfold p (term_sem M s_nil) (eval P (length (p #2))))
  : (tp_sem (iter_tp A B))
/;
intro /A B M d P h_length_pres/.
induction /P/ >> attempt (reduce // >> typecheck).
{
  intro /c/.
  exact /mono_iter_correctness A B M _ _ h_length_pres/.
  reduce // >> extensionality >> reintro /p/ >> reduce // >> compat >> exact /times_1_r _/.
}
{
  intro /d c P ih/.
  rewrite /-> compose_correctness _# 10/ >> reduce //.
  extensionality >> reintro /p/ >> reduce //.
  rewrite /-> mono_iter_correctness _# 5 h_length_pres/ >> reduce //.
  rewrite /-> plus_commute _# 2/.
  rewrite /<- nfold_plus _# 5/.
  applyEq /fn f . f p/ /_/ /ih/ /ih'/ >> clear /ih/ >> reintro /ih/ >> reduce /ih/.
  rewrite /<- ih/ >> repeatn 2 compat.
  rewrite /-> poly_iter_length_pres _# 5 h_length_pres at all/ >> reflexivity.
}
qed ();



endModule ();