openModule /Nat/;
openModule /List/;

File.import "../core/core-load.iml";
File.import "../util/util-load.iml";
File.import "../tools/tools-load.iml";

openModule /Memory/;

beginModule "Interface";



(* TODO: Give push and pop types with less T n duplication *)

(* SEMANTIC STACK INTERFACE *)

define /stack_impl E k bound/
/
  exists 
    (T : nat -> U 0)
    (empty : forall (n : nat) . T n)
    (push : forall (n : nat) . smem n k -> E & T n -> smem n k & ((E & T n) % T n))
    (pop : forall (n : nat) . smem n k -> T n -> smem n k & (unit % (E & T n)))
  . unit
//
  U 0 -> nat -> (nat -> nat) -> U 1
/;
withTypecheck (unfold /stack_impl/). qed ();


define /stack_correct {E k bound} impl/
/
  let T = impl ## 0 in
  let empty = impl ## 1 in
  let push = impl ## 2 in
  let pop = impl ## 3 in
  exists (R : forall (n : nat) . T n -> list E -> U 0) .
  (* R-correct *)
  (forall (n : nat) (s : T n) (l : list E) . R n s l -> length l <= bound n) &
  (* empty-correct *)
  (forall (n : nat) . R n (empty n) nil) &
  (* push-correct *)
  (
    forall (n : nat) (x : E) (s : T n) (l : list E) . R n s l ->
    (length l = bound n : nat -> push n (gen_smem n k) (x, s) #2 = inl (x, s) : _) &
    (length l < bound n -> exists (s' : T n) . push n (gen_smem n k) (x, s) #2 = inr s' : _ & R n s' (x :: l))
  ) &
  (* pop-correct *)
  (
    forall (n : nat) (s : T n) (l : list E) . R n s l ->
    case l : list of
    | nil . pop n (gen_smem n k) s #2 = inl () : _
    | cons x l . exists (s' : T n) . pop n (gen_smem n k) s #2 = inr (x, s') : _ & R n s' l
  )
//
  forall (E : U 0) (k : nat) (bound : nat -> nat) . stack_impl E k bound -> U 1
/;
withTypecheck (unfold /stack_correct/ >> repeatn 4 (unfold /let/)). qed ();



(* LFPL STACK INTERFACE *)



endModule ();