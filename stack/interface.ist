openModule /Nat/;
openModule /List/;

File.import "../core/core-load.iml";
File.import "../util/util-load.iml";
File.import "../sugar/sugar-load.iml";

openModule /Memory/;

beginModule "Interface";



(* STACK INTERFACE *)

define /stack_impl E k/
/
  exists 
    (T : tp)
    (empty : term nil T)
    (push : term nil (arrow (mem k) (arrow (tensor E T) (tensor (mem k) (tensor T (plus E one))))))
    (pop : term nil (arrow (mem k) (arrow T (tensor (mem k) (tensor T (plus one E))))))
  . unit
//
  tp -> nat -> U 0
/;
withTypecheck (unfold /stack_impl/). qed ();



(* STACK CORRECTNESS *)

define /stack_observers_correct n E bound T Valid Items Free/
/
  forall (s : tp_sem T) . Valid s ->
  (Items s = nil : list (tp_sem E) -> Free s = bound : nat) &
  (
    (length (Items s) = bound : nat & Free s = zero : nat) %
    (length (Items s) < bound & (exists (o : nat) . Free s = succ o : nat))
  )
//
  forall (n : nat) (E : tp) (bound : nat) (T : tp) .
  (tp_sem T -> U 0) -> (tp_sem T -> list (tp_sem E)) -> (tp_sem T -> nat) -> U 0
/;
withTypecheck (unfold /stack_observers_correct/). qed ();


define /stack_empty_correct n E bound T Valid Items Free empty/
/
  let empty = term_sem empty s_nil in
  Valid empty & Items empty = nil : _ & Free empty = bound : _
//
  forall (n : nat) (E : tp) (bound : nat) (T : tp) .
  (tp_sem T -> U 0) -> (tp_sem T -> list (tp_sem E)) -> (tp_sem T -> nat) -> term nil T -> U 0
/;
withTypecheck (unfold /stack_empty_correct/). qed ();


define /stack_push_correct n E k bound T Valid Items Free push/
/
  let push = `term_sem _ (arrow (mem k) (arrow (tensor E T) _)) push s_nil in
  forall (m : smem n k) (x : tp_sem E) (s : tp_sem T) . Valid s ->
  exists (s' : tp_sem T) (r : tp_sem E % unit). Valid s' & push m (x, s) = (m, s', r) : _ &
  (
    case Free s : nat of
    | zero . r = inl x : _ & Items s' = Items s : _ & Free s' = Free s : _
    | succ o . r = inr () : _ & Items s' = x :: Items s : _ & Free s' = o : _
  )
//
  forall (n : nat) (E : tp) (k bound : nat) (T : tp) .
  (tp_sem T -> U 0) -> (tp_sem T -> list (tp_sem E)) -> (tp_sem T -> nat) ->
  term nil (arrow (mem k) (arrow (tensor E T) (tensor (mem k) (tensor T (plus E one))))) -> U 0
/;
withTypecheck (unfold /stack_push_correct/). qed ();


define /stack_pop_correct n E k bound T Valid Items Free pop/
/
  let pop = `term_sem _ (arrow (mem k) (arrow T _)) pop s_nil in
  forall (m : smem n k) (s : tp_sem T) . Valid s ->
  exists (s' : tp_sem T) (r : unit % tp_sem E). Valid s' & pop m s = (m, s', r) : _ &
  (
    case Items s : list of
    | nil . r = inl () : _ & Items s' = nil : _ & Free s' = bound : _
    | cons x l . r = inr x : _ & Items s' = l : _ & Free s' = succ (Free s) : _
  )
//
  forall (n : nat) (E : tp) (k bound : nat) (T : tp) .
  (tp_sem T -> U 0) -> (tp_sem T -> list (tp_sem E)) -> (tp_sem T -> nat) ->
  term nil (arrow (mem k) (arrow T (tensor (mem k) (tensor T (plus one E))))) -> U 0
/;
withTypecheck (unfold /stack_pop_correct/). qed ();


define /stack_correct E k bound impl/
/
  let T = impl ## 0 in
  let empty = impl ## 1 in
  let push = impl ## 2 in
  let pop = impl ## 3 in
  forall (n : nat) .
  exists (Valid : tp_sem T -> U 0) (Items : tp_sem T -> list (tp_sem E)) (Free : tp_sem T -> nat) .
  (stack_observers_correct n E (bound n) T Valid Items Free) &
  (stack_empty_correct n E (bound n) T Valid Items Free empty) &
  (stack_push_correct n E k (bound n) T Valid Items Free push) &
  (stack_pop_correct n E k (bound n) T Valid Items Free pop)
//
  forall (E : tp) (k : nat) . (nat -> nat) -> stack_impl E k -> U 1
/;
withTypecheck (unfold /stack_correct, let/). qed ();



(* STACK PROPERTIES *)

lemma "stack_len_items_plus_free_eq_bound"
/
  forall (E : tp) (k : nat) (bound : nat -> nat)
  (impl : stack_impl E k) (impl_correct : stack_correct E k bound impl) (n : nat) .
  let correct = impl_correct n in
  let T = impl ## 0 in
  let Valid = correct ## 0 in
  let Items = correct ## 1 in
  let Free = correct ## 2 in
  forall (s : tp_sem T) . Valid s -> length (Items s) + Free s = bound n : nat
/;
intro /E k bound impl impl_correct n/. unfold /let at all/.
unfold /stack_correct in impl_correct, let in impl_correct at all/.
generalize /impl_correct n/ /_/ /correct/. clear /impl_correct/.
destruct /correct/ /Valid Items Free observers_correct _ _ pop_correct/. reduce //.
intro /s s_valid/.
unfold /stack_observers_correct in observers_correct, stack_pop_correct in pop_correct, let in pop_correct/.
so /pop_correct (gen_smem n k)/ /tmp/. clear /pop_correct/. reintro /pop_correct/.
remember /length (Items s)/ /nat/ /len/ /len_eq/.
revert /s s_valid len_eq/.
induction /len/.
{
  intro /s s_valid len_eq/.
  apply /observers_correct s s_valid #1/.
  apply /length_zero_form/. auto.
}
{
  intro /len ih s s_valid len_eq/.
  so /length_succ_form _# 4 (eq_symm _# 4 len_eq)/ /x xs items_eq/.
  so /pop_correct s s_valid/ /s' r s'_valid pop_eq pop_observed/. clear /pop_correct/.
  rewrite /-> items_eq in pop_observed/.
  revert /len_eq/. rewrite /-> items_eq/. reduce //. intro /len_eq/.
  injection /len_eq/. clear /len_eq/. reintro /len_eq/.
  destruct /pop_observed/ /_ s'_items s'_free/.
  subst /xs/. so /ih s' s'_valid len_eq/ /ih_s'/. clear /ih/. omega. 
}
qed ();



endModule ();