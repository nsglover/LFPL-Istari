openModule /Nat/;
openModule /List/;

File.import "../core/core-load.iml";
File.import "../util/util-load.iml";
File.import "../tools/tools-load.iml";

File.loadWithoutDependencies "interface.isto";

openModule /Interface/;

beginModule "Base";



(* BASE CASE IMPLEMENTATION *)

define /T E c/
/
  nfold one (fn acc . tensor (plus one E) acc) c
//
  tp -> nat -> tp
/;
withTypecheck (unfold /T/). qed ();
reductions
/
  T _ (zero) --> one ;
  T E (succ c) --> tensor (plus one E) (T E c) ;
  unfolding T
/;


defineInd /E/
/
  empty : forall (c : nat) . term nil (T E c) of
  | zero . triv
  | succ c . pair all_left (inj1 triv) (empty c)
//
  forall (E : tp) (c : nat) . term nil (T E c)
/;


defineInd /E/
/
  push : forall (c : nat) . term nil (arrow (tensor E (T E c)) (plus (tensor E (T E c)) (T E c))) of
  | zero . lam (inj1 var)
  | succ c . 
    lam
    (
      letp all_left var
      (
        letp (right all_left) var
        (
          match (left all_right) var
          (
            match (right all_left) (app all_right (push c) (pair (right all_left) var var))
            (letp (left all_right) var (inj2 (pair (left all_right) (inj2 var) var)))
            (inj2 (pair (right all_left) (inj1 var) var))
          )
          (inj1 (pair (right (right all_left)) var (pair (left all_right) (inj2 var) var)))
        )
      )
    )
//
  forall (E : tp) (c : nat) . term nil (arrow (tensor E (T E c)) (plus (tensor E (T E c)) (T E c)))
/;


defineInd /E/
/
  pop : forall (c : nat) . term nil (arrow (T E c) (plus one (tensor E (T E c)))) of
  | zero . lam (inj1 triv)
  | succ c . 
    lam
    (
      letp all_left var
      (
        match (left all_right) var
        (
          match (right all_left) (app all_right (pop c) var)
          (inj1 var)
          (letp (left all_right) var (inj2 (pair (left all_right) var (pair (right all_left) (inj1 var) var))))
        )
        (inj2 (pair (left all_right) var (pair all_right (inj1 triv) var)))
      )
    )
//
  forall (E : tp) (c : nat) . term nil (arrow (T E c) (plus one (tensor E (T E c))))
/;


define /base_case_impl E c/
/
  (
    (fn _ . tp_sem (T E c)),
    (fn _ . term_sem (empty E c) s_nil), 
    (fn _ . `term_sem _ (arrow one _) (lam (lam (pair (right all_left) var (app all_right (push E c) var)))) s_nil),
    (fn _ . `term_sem _ (arrow one _) (lam (lam (pair (right all_left) var (app all_right (pop E c) var)))) s_nil),
    ()
  )
//
  forall (E : tp) (c : nat) . stack_impl (tp_sem E) zero (fn _ . c)
/;
withTypecheck (unfold /stack_impl, base_case_impl/) >> reflexivity. qed ();



(* BASE CASE CORRECTNESS *)

lemma "base_case_correct"
/
  forall (E : tp) (c : nat) . stack_correct (base_case_impl E c)
/;
inference >> unfold /stack_correct/.
intro /E c/ >> repeatn 4 (unfold /let/) >> reduce // >> induction /c/.
{
  repeat (unfold /base_case_impl/).
  exists /fn _ _ l . l = nil : _/ >> reduce //.
  split >>> [intro /n s l h/ >> rewrite /-> h/ >> exact /leq_0_min zero/, split >>> [intro /n/ >> reflexivity, idtac]].
  split.
  {
    intro /n x s l h_R/.
    split >>> [auto, omega].
  }
  {
    intro /n s l h_R/.
    rewrite /-> h_R/.
    reflexivity.
  }
}
{
  repeat (unfold /base_case_impl/) >> reduce // >> intro /c ih/.
  destruct /ih/ /R R_correct empty_correct push_correct pop_correct/.
  exists
  /
    fn n p l . let (x, xs) = p in
    case x of
    | inl _ . R n xs l
    | inr x . exists (l' : list (tp_sem E)) . l = x :: l' : _ & R n xs l' & length l' = c : nat
  / >> reduce //.
  (* R-correct *)
  split.
  {
    (intro /n s l/ >> destruct /s/ /y ys/ >> destruct /y/ /u | y/ >> reduce //) >>>
    [
      intro /h_R/ >> transitivity /c/ >>> [exact /R_correct n ys l h_R/, exact /leq_succ c/],
      intro /h_R/ >> destruct /h_R/ /l' h_l_eq h_R h_len/ >> subst /l/ >> reduce // >> apply /leq_succ_succ/ >> omega
    ].
  }
  split >>> [exact /empty_correct/, split].
  (* push-correct *)
  {
    clear /empty_correct pop_correct/.
    intro /n x s l h_R/ >> destruct /s/ /y ys/ >> destruct /y/ /u | y/ >> reduce /concl h_R/.
    {
      split >>> [intro /h_len/ >> so /R_correct n ys l h_R/ /tmp/ >> omega, idtac].
      so /push_correct n x ys l h_R/ /tmp/ >> clear /push_correct/ >> reintro /push_correct/.
      intro /h_len/ >> unfold /lt in h_len/.
      so /leq_succ_invert _# 2 h_len/ /tmp/ >> clear /h_len/ >> reintro /h_len/.
      so /leq_iff_lt_or_eq _# 2 #1 h_len/ /tmp/ >> clear /h_len/ >> reintro /h_len/.
      destruct /h_len/ /h_len | h_len/.
      {
        destruct /push_correct/ /_ push_correct/.
        so /push_correct h_len/ /tmp/ >> clear /h_len push_correct/ >> reintro /push_correct/.
        destruct /push_correct/ /s' push_correct/.
        exists /(inl u, s')/ >> reduce //.
        destruct /push_correct/ /push_eq F_eq/.
        rewrite /-> push_eq/ >> reduce // >> split >>> [reflexivity, exact /F_eq/].
      }
      {
        destruct /push_correct/ /push_correct _/.
        so /push_correct h_len/ /tmp/ >> clear /push_correct/ >> reintro /push_correct/.
        rewrite /-> push_correct/ >> reduce //.
        exists /(inr x, ys)/ >> reduce // >> split >>> [reflexivity, idtac].
        exists /l/ >> auto.
      }
    }
    {
      clear /push_correct/ >> split >>> [intro /tmp/ >> reflexivity, idtac].
      intro /h_len/ >> exfalso.
      destruct /h_R/ /l' h_l_eq h_R h_len_l'/.
      subst /l/ >> reduce /h_len/ >> omega.
    }
  }
  (* pop-correct *)
  {
    clear /empty_correct push_correct/.
    intro /n s l h_R/ >> destruct /s/ /y ys/ >> destruct /y/ /u | y/ >> reduce /concl h_R/.
    {
      so /pop_correct n ys l h_R/ /tmp/ >> clear /pop_correct/ >> reintro /pop_correct/.
      (destruct /l/ /| x l/ >> reduce /concl pop_correct/) >>> [rewrite /-> pop_correct/ >> auto, idtac].
      destruct /pop_correct/ /s' pop_eq h_R'/.
      rewrite /-> pop_eq/ >> reduce //.
      exists /(inl u, s')/ >> split >>> [reflexivity, reduce // >> exact /h_R'/].
    }
    {
      destruct /h_R/ /l' h_l_eq h_R' h_len/ >> subst /l/.
      exists /(inl (), ys)/ >> split >>> [reflexivity, exact /h_R'/].
    }
  }
}
qed ();



endModule ();