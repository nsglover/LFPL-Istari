File.import "../core/core-load.iml";
File.import "../util/util-load.iml";

beginModule "Bit";



(* BOOLEANS AND BIT VECTORS *)

define /bit_tp/
/
  plus one one
//
  tp
/;
withTypecheck (unfold /bit_tp/). qed ();
setOpacity /bit_tp/ Constant.SOFT;


define /bitvec_tp n/
/
  nfold one (fn acc . tensor bit_tp acc) n
//
  nat -> tp
/;
withTypecheck (unfold /bitvec_tp/). qed ();
reductions
/
  bitvec_tp (zero) --> one ;
  bitvec_tp (succ n) --> tensor bit_tp (bitvec_tp n) ;
  unfolding bitvec_tp
/;


lemma "bitvec_semantics"
/
  forall (n : nat) . tp_sem (bitvec_tp n) = bitvec n : U 0
/;
intro /n/ >> induction /n/ >> auto. qed ();


define /ff {G}/
/
  inj1 triv
//
  forall (G : ctx) . term G bit_tp
/;
withTypecheck (unfold /ff/). qed ();
reductions
/
  term_sem _ _ (ff _) _ --> inl () ;
  unfolding ff
/;


define /tt {G}/
/
  inj2 triv
//
  forall (G : ctx) . term G bit_tp
/;
withTypecheck (unfold /tt/). qed ();
reductions
/
  term_sem _ _ (tt _) _ --> inr () ;
  unfolding tt
/;


define /ifthenelse {G GM GN A} T M Ntt Nff/
/
  match T M (drop Nff) (drop Ntt)
//
  forall (G GM GN : ctx) (A : tp) . split G GM GN -> term GM bit_tp -> term GN A -> term GN A -> term G A
/;
withTypecheck (unfold /ifthenelse/). qed ();
reductions
/
  term_sem _ _ (ifthenelse G GM GN A T M Ntt Nff) S -->
    let (SM, SN) = s_split tp_sem G GM GN T S in
    (
      case term_sem GM bit_tp M SM of
      | inl _ . term_sem GN A Nff SN
      | inr _ . term_sem GN A Ntt SN
    ) ;
  unfolding ifthenelse bit_tp Tuple.letpair
/;



endModule ();