openModule /Nat/;
openModule /List/;

File.import "../core/core-load.iml";
File.import "../util/util-load.iml";

beginModule "Memory";



(* LFPL MEMORY TYPE *)

define /mem k/
/
  nfold one (fn acc . tensor (dlist one) acc) k
//
  nat -> tp
/;
withTypecheck (unfold /mem/). qed ();
reductions
/
  mem (zero) --> one ;
  mem (succ k) --> tensor (dlist one) (mem k) ;
  unfolding mem
/;



(* STRUCTURED MEMORY *)

lemma "tabulate_mem"
/
  forall (n : nat) (m : { l : list unit | length l = n : nat }) . m = tabulate n (fn _ . ()) : list unit
/;
intro /n/. induction /n/.
{
  intro /(m h_len)/. unhide.
  autoWith /length_zero_form/.
}
{
  intro /n ih (m h_len)/. unhide.
  so /length_succ_form _ unit m n h_len/ /(x xs h_eq)/. subst /m/.
  compat >>> [extensionality, idtac].
  apply /ih/. split. reduce /h_len/. injection /h_len/. auto.
}
qed ();


define /smem n k/
/
  nfold unit (fn acc . { l : list unit | length l = n : nat } & acc) k
//
  intersect (i : level) . nat -> nat -> U i
/;
withTypecheck (unfold /smem/). qed ();
reductions
/
  smem _ (zero) --> unit ;
  smem n (succ k) --> { l : list unit | length unit l = n : nat } & (smem n k) ;
  unfolding smem
/;


lemma "smem_sub_mem"
/
  forall (n k : nat) . smem n k <: tp_sem (mem k)
/;
intro /n k/ >> induction /k/ >> auto. qed ();


defineInd /n/
/
  gen_smem : forall (k : nat) . smem n k of
  | zero . ()
  | succ k . (tabulate n (fn _ . ()), gen_smem k)
//
  forall (n k : nat) . smem n k
/;
autoWith /length_tabulate/.
qed ();



endModule ();