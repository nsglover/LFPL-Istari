File.import "language-load.iml";
File.import "substitution-load.iml";
File.import "semantics-load.iml";

beginModule "Sugar";

openModule /List/;
openModule /Language/;
openModule /Substitution/;
openModule /Semantics/;



(* LIST NIL AND CONS *)

define /lnil {G A}/
/
  lfold (inj1 triv)
//
  forall (G : ctx) (A : tp) . term G (dlist A)
/;
withTypecheck (unfold /lnil/). qed ();
reductions
/
  term_sem _ _ (lnil _ _) _ --> nil ;
  unfolding lnil
/;


define /lcons {G Gd Ght Gh Gt A} T Tht Md Mh Mt/
/
  lfold (inj2 (pair T Md (pair Tht Mh Mt)))
//
  forall (G Gd Ght Gh Gt : ctx) (A : tp) . split G Gd Ght -> split Ght Gh Gt ->
  term Gd diam -> term Gh A -> term Gt (dlist A) -> term G (dlist A)
/;
withTypecheck (unfold /lcons/). qed ();
reductions
/
  term_sem _ _ (lcons G Gd Ght Gh Gt A T Tht Md Mh Mt) S --> 
    let (_, Sht) = s_split tp_sem G Gd Ght T S in
    let (Sh, St) = s_split tp_sem Ght Gh Gt Tht Sht in
    term_sem Gh A Mh Sh :: term_sem Gt (dlist A) Mt St ;
  unfolding lcons Tuple.letpair
/;



(* LIST FOLDR AND FOLDL *)

define /lrec_foldr {G GA GB A B} T M N1 N2/
/
  app T
  (
    lrec M
    (
      match all_left var
      (
        drop (lam var)
      )
      (
        letp all_left var
        (
          letp (right all_left) var
          (
            lam
            (
              app (right (left (right all_left))) (lam N2) (app (right all_left) var var)
            )
          )
        )
      )
    )
  )
  N1
//
  forall (G GA GB : ctx) (A B : tp) .
  split G GA GB -> term GA (dlist A) -> term GB B -> term (B :: A :: diam :: nil) B ->
  term G B
/;
withTypecheck (unfold /lrec_foldr/). qed ();

lemma "lrec_foldr_correctness"
/
  forall (G GA GB : ctx) (A B : tp) (T : split G GA GB) (S : subst tp_sem G) .
  forall (M : term GA (dlist A)) (N1 : term GB B) (N2 : term (B :: A :: diam :: nil) B) .
  term_sem (lrec_foldr T M N1 N2) S =
  (
    foldr (term_sem N1 (s_split T S #2))
    (fn va acc . term_sem N2 (scons acc (scons va (scons () snil))))
    (term_sem M (s_split T S #1))
  ) : tp_sem B
/;
inference.
intro /G GA GB A B T S M N1 N2/.
unfold /lrec_foldr/.
reduce //.
unfold /Tuple.letpair/.
generalize /term_sem M (s_split T S #1)/ /_/ /v/.
induction /v/ >>> [reflexivity, idtac].
intro /v vs ih/.
rewrite /-> ih/.
reflexivity.
qed ();


define /lrec_foldl {G GA GB A B} T M N1 N2/
/
  app T
  (
    lrec M
    (
      match all_left var
      (
        drop (lam var)
      )
      (
        letp all_left var
        (
          letp (right all_left) var
          (
            lam
            (
              app (right (right (left all_right))) var N2
            )
          )
        )
      )
    )
  )
  N1
//
  forall (G GA GB : ctx) (A B : tp) .
  split G GA GB -> term GA (dlist A) -> term GB B -> term (B :: A :: diam :: nil) B ->
  term G B
/;
withTypecheck (unfold /lrec_foldl/). qed ();

lemma "lrec_foldl_correctness"
/
  forall (G GA GB : ctx) (A B : tp) (T : split G GA GB) (S : subst tp_sem G) .
  forall (M : term GA (dlist A)) (N1 : term GB B) (N2 : term (B :: A :: diam :: nil) B) .
  term_sem (lrec_foldl T M N1 N2) S =
  (
    foldl (term_sem N1 (s_split T S #2)) 
    (fn va acc . term_sem N2 (scons acc (scons va (scons () snil))))
    (term_sem M (s_split T S #1))
  ) : tp_sem B
/;
inference.
intro /G GA GB A B T S M N1 N2/.
unfold /lrec_foldl/.
reduce //.
unfold /Tuple.letpair/.
generalize /term_sem M (s_split T S #1)/ /_/ /v/.
generalize /term_sem N1/ /_/ /f/.
revert /f/.
induction /v/ >>> [intros >>+ reflexivity, idtac].
intro /v vs ih f/.
exact /ih (fn SN . term_sem N2 (scons (f SN) (scons v (scons () snil))))/.
qed ();



(* LIST CASE ANALYSIS *)

define /lunfold {G A} M/
/
  lrec M 
  (
    match all_left var (inj1 triv)
    (
      letp all_left var
      (
        letp (right all_left) var
        (
          inj2
          (
            pair (right (right all_left)) var
            (
              pair (left all_right) var (lfold var)
            )
          )
        )
      )
    )
  )
//
  forall (G : ctx) (A : tp) .
  term G (dlist A) -> term G (plus one (tensor diam (tensor A (dlist A))))
/;
withTypecheck (unfold /lunfold/). qed ();

lemma "lunfold_correctness"
/
  forall (G : ctx) (A : tp) (M : term G (dlist A)) (S : subst tp_sem G) . 
  term_sem (lunfold M) S = 
  (
    case term_sem M S : list of
    | nil . inl ()
    | cons v vs . inr ((), v, vs)
  ) : (unit % (unit & tp_sem A & list (tp_sem A)))
/;
inference.
intro /G A M S/.
unfold /lunfold/ >> reduce // >> unfold /Tuple.letpair/.
generalize /term_sem M S/ /_/ /v/ >> clear /M/.
induction /v/ >>> [reflexivity, idtac].
{
  intro /v vs ih/.
  repeatn 3 compat.
  rewrite /-> ih/.
  destruct /vs/ /| v' vs'/ >> reduce // >> reflexivity.
}
qed ();


define /lmatch {G GM GN A B} T M N1 N2/
/
  match T (lunfold M) (drop N1)
  (
    letp (left all_right) var
    (
      letp (right (left all_right)) var N2
    )
  )
//
  forall (G GM GN : ctx) (A B : tp) .
  split G GM GN -> term GM (dlist A) -> term GN B -> term (A :: dlist A :: diam :: GN) B ->
  term G B
/;
withTypecheck (unfold /lmatch/). qed ();

lemma "match_correctness"
/
  forall (G GM GN : ctx) (A B : tp) (T : split G GM GN) (S : subst tp_sem G) .
  forall (M : term GM (dlist A)) (N1 : term GN B) (N2 : term (A :: dlist A :: diam :: GN) B) . 
  term_sem (lmatch T M N1 N2) S = 
  (
    let (SM, SN) = s_split T S in
    (
      case term_sem M SM : list of
      | nil . term_sem N1 SN
      | cons v vs . term_sem N2 (scons v (scons vs (scons () SN)))
    )
  ) : tp_sem B
/;
inference.
intro /G GM GN A B T S M N1 N2/.
unfold /lmatch/.
reduce //.
repeatn 4 (unfold /Tuple.letpair/).
remember /term_sem (lunfold M) (s_split T S #1)/ /_/ /unfold_v/ /h_unfold_v/.
rewrite /-> lunfold_correctness _# 4 in h_unfold_v/.
revert /h_unfold_v/.
generalize /term_sem M (s_split T S #1)/ /_/ /v/.
intro /h_unfold_v/.
destruct /v/ /| v vs/ >> subst /unfold_v/ >> auto.
qed ();



endModule ();