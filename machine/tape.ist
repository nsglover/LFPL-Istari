openModule /Nat/;
openModule /Option/;
openModule /List/;

beginModule "Tape";



(* TAPE ALPHABET *)

define /symbol a/
/
  unit % a
//
  intersect (i : level) . U i -> U i
/;
withTypecheck (unfold /symbol/). qed ();
setOpacity /symbol/ Constant.SOFT;


define /blank_symbol/
/
  inl ()
//
  intersect (i : level) (a : U i) . symbol a
/;
withTypecheck (unfold /blank_symbol/). qed ();


define /new_symbol x/
/
  inr x
//
  intersect (i : level) (a : U i) . a -> symbol a
/;
withTypecheck (unfold /new_symbol/). qed ();



(* TAPE INTERFACE *)

define /tape a/
/
  list (symbol a) & (symbol a) & list (symbol a)
//
  intersect (i : level) . U i -> U i
/;
withTypecheck (unfold /tape/). qed ();


define /tape_init {a} input/
/
  (nil, blank_symbol, map new_symbol input)
//
  intersect (i : level) . forall (a : U i) . list a -> tape a
/;
withTypecheck (unfold /tape_init, tape/). qed ();


define /tape_head {a} T/
/
  let (_, xr) = T in
  let (x, _) = xr in
  x
//
  intersect (i : level) . forall (a : U i) . tape a -> symbol a
/;
withTypecheck (unfold /tape_head, tape/). qed ();


define /tape_write {a} x T/
/
  let (l, xr) = T in
  let (_, r) = xr in
  (l, x, r)
//
  intersect (i : level) . forall (a : U i) . symbol a -> tape a -> tape a
/;
withTypecheck (unfold /tape_write, tape at all/). qed ();


define /tape_shift {a} dir T/
/
  let (l, xr) = T in
  let (x, r) = xr in
  case dir of
  | inl _ .
    case l : list of
    | nil . (nil, blank_symbol, x :: r)
    | cons y l . (l, y, x :: r)
  | inr _ .
    case r : list of
    | nil . (x :: l, blank_symbol, nil)
    | cons y r . (x :: l, y, r)
//
  intersect (i : level) . forall (a : U i) . unit % unit -> tape a -> tape a
/;
withTypecheck (unfold /tape_shift, tape at all/). qed ();


define /tape_size {a} T/
/
  let (l, xr) = T in
  let (_, r) = xr in
  succ (length l + length r)
//
  intersect (i : level) . forall (a : U i) . tape a -> nat
/;
withTypecheck (unfold /tape_size, tape/). qed ();


define /tape_output {a} n T/
/
  let (_, xr) = T in
  let (_, r) = xr in
  foldr nil (fn x acc . case x of | inl _ . acc | inr x . x :: acc) (keep n r)
//
  intersect (i : level) . forall (a : U i) . nat -> tape a -> list a
/;
withTypecheck (unfold /tape_output, tape/). qed ();



endModule ();