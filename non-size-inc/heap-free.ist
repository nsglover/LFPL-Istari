openModule /Nat/;
openModule /List/;

File.import "../core/core-load.iml";
File.import "../util/util-load.iml";

File.loadWithoutDependencies "size.isto";

openModule /Size/;

beginModule "HeapFree";



(* HEAP-FREE TYPE *)

typedef
/
  datatype
    intersect (i : level) . U i
  of
    heap_free : tp -> type =
    | hf_one : heap_free one
    | hf_plus : forall (A B : tp) . heap_free A -> heap_free B -> heap_free (plus A B)
    | hf_tensor : forall (A B : tp) . heap_free A -> heap_free B -> heap_free (tensor A B)
/;
Database.setImplicits (parseConstant /hf_plus/) 2;
Database.setImplicits (parseConstant /hf_tensor/) 2;



(* DUPLICATION *)

defineInd //
/
  dup : heap_free A -> forall (G : ctx) . term G A -> term G (tensor A A) of
  | hf_one . fn _ _ . pair all_right triv triv
  | hf_plus A B HA HB . fn _ M .
    match all_left M
    (
      letp all_left (dup HA _ var) 
      (
        pair (left all_right) (inj1 var) (inj1 var)
      )
    )
    (
      letp all_left (dup HB _ var) 
      (
        pair (left all_right) (inj2 var) (inj2 var)
      )
    )
  | hf_tensor A B HA HB . fn _ M .
    letp all_left M
    (
      letp (left all_right) (dup HA _ var)
      (
        letp (right (right all_left)) (dup HB _ var)
        (
          pair (right (left (right all_left)))
          (
            pair (right all_left) var var
          )
          (
            pair (right all_left) var var
          )
        )
      )
    )
//
  forall (A : tp) . heap_free A -> forall (G : ctx) . term G A -> term G (tensor A A)
/;
Database.setImplicits (parseConstant /dup/) 1;

lemma "dup_correct"
/
  forall (A : tp) (HA : heap_free A) (G : ctx) (S : subst tp_sem G) (M : term G A) .
  term_sem (dup HA G M) S = (term_sem M S, term_sem M S) : (tp_sem A & tp_sem A)
/;
intro /A HA/.
induction /HA/ >> auto.
{
  intro /G S M/.
  reduce //.
  extensionalityAuto.
}
{
  intro /A B HA ih_A HB ih_B G S M/.
  generalize /term_sem M S/ /tp_sem A % tp_sem B/ /v/. 
  andthenl (destruct /v/ /v | v/ >> reduce //) [rewrite /-> ih_A _ _ _/, rewrite /-> ih_B _ _ _/] >>
  extensionalityAuto >> reduce // >> reflexivity.
}
{
  intro /A B HA ih_A HB ih_B G S M/.
  generalize /term_sem M S/ /tp_sem A & tp_sem B/ /v/.
  destruct /v/ /v1 v2/ >> reduce //.
  andthen (rewrite /-> ih_B _ _ _/ >> reduce //) (rewrite /-> ih_A _ _ _/ >> reduce //).
  reflexivity.
}
qed ();



(* CONTRACTION *)

define /contraction {G A B} HA M/
/
  letp (left all_right) (dup HA _ var) M
//
  forall (G : ctx) (A B : tp) . heap_free A -> term (A :: A :: G) B -> term (A :: G) B
/;
withTypecheck (unfold /contraction/). qed ();

lemma "contraction_correct"
/
  forall (G : ctx) (A B : tp) (S : subst tp_sem G) (v : tp_sem A) (HA : heap_free A) (M : term (A :: A :: G) B) .
  term_sem M (s_cons v (s_cons v S)) = term_sem (contraction HA M) (s_cons v S) : tp_sem B
/;
inference.
intro /G A B s v HA M/ >> unfold /contraction/ >> reduce //.
rewrite /-> dup_correct A HA (A :: nil) (s_single v) var/ >> reduce //.
reflexivity.
qed ();



(* SIZE OF HEAP-FREE VALUES *)

lemma "heap_free_has_size"
/
  forall (A : tp) (HA : heap_free A) (v : tp_sem A) . has_size v
/;
intro /A HA/.
induction /HA/.
{
  auto.
}
{
  intro /A B HA ih_A HB ih_B v/.
  destruct /v/ /v1 | v2/ >> reduce // >> auto.
}
{
  intro /A B HA ih_A HB ih_B v/.
  destruct /v/ /v1 v2/ >> reduce // >> auto.
}
qed ();

lemma "heap_free_size_zero"
/
  forall (A : tp) (HA : heap_free A) (v : tp_sem A) (v_has_size : has_size v).
  size v_has_size = 0 : nat
/;
intro /A HA/.
induction /HA/.
{
  auto.
}
{
  intro /A B HA ih_A HB ih_B v v_has_size/.
  destruct /v/ /v1 | v2/ >> reduce // >> auto.
}
{
  intro /A B HA ih_A HB ih_B v v_has_size/.
  destruct /v/ /v1 v2/ >> reduce //.
  rewrite /-> ih_A v1 (v_has_size #1)/.
  rewrite /-> ih_B v2 (v_has_size #2)/.
  auto.
}
qed ();


lemma "heap_free_list_size_length"
/
  forall (A : tp) (HA : heap_free A) (v : tp_sem (dlist A)) (v_has_size : `has_size (dlist A) v).
  `size (dlist A) v v_has_size = length v : nat
/;
intro /A HA v/.
induction /v/.
{
  intro /nil_has_size/.
  destructThin /nil_has_size/ /{}/.
  reduce // >> reflexivity.
}
{
  intro /v vs ih cons_has_size/.
  destructThin /cons_has_size/ /{v_has_size vs_has_size}/.
  {
    auto.
  }
  {
    auto.
  }
  reduce //.
  so /heap_free_size_zero A HA v v_has_size/ /v_size_0/.
  reduce /v_size_0/.
  rewrite /-> v_size_0/.
  rewrite /-> plus_0_l _/.
  compat.
  exact /ih vs_has_size/.
}
qed ();



(* THE NON-LENGTH INCREASING PROPERTY *)

lemma "non_length_increasing"
/
  forall (A : tp) (HA : heap_free A) (M : term nil (arrow (dlist A) (dlist A))) (v : tp_sem (dlist A)) .
  length ((term_sem M s_nil) v) <= length v
/;
intro /A HA M v/.
assert /`has_size (dlist A) v/ /v_has_size/.
{
  reduce //.
  induction /v/ >>> [exact /Forall_nil _/, idtac].
  intro /v vs vs_has_size/ >> exact /Forall_cons _ v vs (heap_free_has_size A HA v) vs_has_size/.
}
so /size_total_and_bounded nil _ M s_nil/ /M_has_size M_bound/.
destruct /M_has_size/ /M_pres M_size M_non_size_inc/.
reduce /M_bound/ >> rewrite /-> leq_0_minimal M_size M_bound in M_non_size_inc/ >> clear /M_size M_bound/.
so /M_non_size_inc v v_has_size/ /size_Mv_le_v/ >> clear /M_non_size_inc/.
so /heap_free_list_size_length A HA v v_has_size/ /v_size_eq_length/.
so /heap_free_list_size_length A HA ((term_sem M s_nil) v) (M_pres v v_has_size)/ /Mv_size_eq_length/ >> auto.
reduce /v_size_eq_length/ >> reduce /Mv_size_eq_length/ >> reduce /size_Mv_le_v/.
rewrite /-> v_size_eq_length in size_Mv_le_v/.
rewrite /-> Mv_size_eq_length in size_Mv_le_v/.
clear /v_size_eq_length Mv_size_eq_length/.
exact /size_Mv_le_v/.
qed ();



endModule ();